#!/bin/bash


alias diff='diff_function'


check_if_repo_exists(){
    #Prüfen, ob ein GIT Repo gefunden wurde
    if [[ "$git_status" == *"Kein Git-Repo"* || "$git_status" == *"not a git repository"* ]]; then
        echo -e "\e[31mEs wurde kein GIT Repository gefunden\e[0m"
        return 1
    fi
}


check_for_unmanaged_files(){
    #Prüfen, ob es noch gelöschte, neue oder unversionierte Dateien gibt, diese erst direkt in der Shell bearbeitet werden sollen
    if [[ "$git_status" == *"Untracked file"* || "$git_status" == *"deleted"* || "$git_status" == *"Unversioniert"* || "$git_status" == *"gelöscht"* ]]; then
        echo -e "\e[33mEs gibt noch Dateien, die gelöscht oder unversioniert sind. Sollen diese jetzt bearbeitet werden?\e[0m"
        read -e answer
        [[ $answer =~ ^[YyJj]$ ]] && return 1
    fi
    return 0
}


commit_files(){
    #Die Dateien durchgehen und gegebenenfalls committen
    git_status=$(git status 2>&1)
    unset commit_messages
    changed=false
    file_counter=1


    for file in $files; do #Gehe alle Files durch

        file=$(echo $file | sed 's/}/ /g')
        echo -e "\e[1;96m"; center "Datei: $file ($file_counter/$(echo $files | wc -w))"; echo -e "\e[0m\n\n" #Dateinamen mittig und fett anzeigen
        if [[ "$(git diff "$file" 2>&1)" == *"Permission denied"* && "$file" != *"diff/function"* ]]; then
            echo -e "\e[31mDie Datei \"$file\" ist noch in einem anderen Programm geöffnet. Bitte dieses Programm zuerst schließen!\e[0m\n"
            ((file_counter ++))
            continue
        fi

        if [[ -z $( git diff "$file" ) ]]; then #Für Dateien, bei denen kein Diff angezeigt werden kann, z.b. .pdf
            if [[ $(git status | grep "$file") =~ (neue Datei|new file) ]]; then
                echo -e "\e[32mFür die Datei \"$file\" ist kein Diff verfügbar, da sie neu ist\e[0m"
            else
                echo -e "\e[33mFür die Datei \"$file\" ist kein Diff verfügbar!\e[0m"
            fi
        fi

        if [[ -z $(git diff --summary "$file") ]]; then #Blieben die Rechte der Datei gleich?
            git --no-pager diff --color=always --unified=5 "$file" | tail -n +5 #ohne pager, dass alles direkt ausgedruckt wird; unified gibt den Kontext an
        else #Rechteänderungen anzeigen
            echo -ne "\e[33m"
            git diff --summary "$file" | sed 's/ mode change/Die Rechte der Datei haben sich geändert von/' | sed 's/100//g' | sed 's/\=>/auf/' | grep -oE --color=never '.+[0-9]' #Zeigt Rechteänderungen an
            echo -e "\e[0m"
            git --no-pager diff --color=always --unified=5 "$file" | tail -n +7 #Mehr Abschneiten, da der Rechtewechsel auch im diff enthalten ist
        fi
        print_line "-"


        echo -e "\e[1;96mWie soll die Commit-Nachricht lauten?\e[0m"
        [[ ${#commit_messages[@]} != 0 ]] && echo -e "Die letzten Commit Nachrichten: \e[2m(Um eine davon zu benutzen, die entsprechende Zahl angeben)\e[0m" #Wenn es vorherige Commits gibt werden diese nun angezeigt
        commit_counter=0
        for commit in ${commit_messages[@]} ; do
            (( commit_counter ++ ))
            [[ -z ${commit_messages[commit_counter]} ]] || echo -e "    $commit_counter      ${commit_messages[commit_counter]}"
        done
        echo -e "\nAlternativ kann auch folgendes angegeben werden:\n    a      Abbrechen\n    co     Die lokalen Änderungen verwerfen\n    l      Die letzte Commitnachricht verwenden\nDie Datei wird übersprungen, wenn nichts angegeben wird\n"
        read -e commit_message


        if [[ -z $commit_message ]]; then #Keine Nachricht angegeben
            echo -e "\e[33mEs wurde keine Nachricht angegeben, somit die Datei wird übersprungen\e[0m"
            ((file_counter ++))
            continue

        elif [[ $commit_message =~ ^[0-9]+$ ]]; then #Eine Zahl angegeben
            if [[ ${commit_messages[commit_message]} != "0" ]]; then #Gibt es einen Commit, auf den die Zahl trifft? Wenn ja, benutze ihn
                echo -e "Es wird die Nachricht aus einem vorherigen Commit benutzt: \"${commit_messages[commit_message]}\""
                git commit -s "$file" -m "${commit_messages[commit_message]}" || echo -e "\e[31mEs gab ein Problem beim Commit!\e[0m"
                last_commit_message=${commit_messages[commit_message]}
            else #Sonst verwerfe ihn
                echo -e "\e[33mEs wurde keine Nachricht angegeben, somit die Datei wird übersprungen\e[0m"
		        ((file_counter ++))
                continue
            fi

        elif [[ $commit_message =~ ^[Aa]$ ]]; then #Abbrechen
            echo -e "\e[31mAbbrechen\e[0m"
            return 1

        elif [[ $commit_message =~ ^(co|Co|cO|CO)$ ]]; then #Cechkout HEAD
            echo -e "\n\e[33mSollen die Änderungen wirklich zurückgesetzt werden?\e[0m \e[2m(J/N)\e[0m"
            read -e answer
            if [[ $answer =~ ^[YyJj]$ ]]; then
                echo -e "\e[33mDie Änderungen werden gelöscht\e[0m"
                git checkout HEAD "$file" || echo -e "\e[31mEs gab ein Problem beim Zurücksetzten!\e[0m"
                [[ $(file $file) == *"CRLF"* ]] && echo && to_lf "$file"
            else
                echo -e "\e[32mDie Änderungen werden nicht gelöscht\e[0m"
            fi
            ((file_counter ++))
            continue

        elif [[ $commit_message =~ ^[Ll]$ ]]; then #Der letzte Commit soll verwendet werden
            if [[ $last_commit_message == "" ]]; then #Gibt es einen letzten Commit?
                echo -e "\e[33mEs gibt keine letzte Commitnachricht, somit die Datei wird übersprungen\e[0m"
		        ((file_counter ++))
                continue
            fi
            echo "Die letzte Commit-Nachricht wird verwendet"
            git commit -s "$file" -m "$last_commit_message" || echo -e "\e[31mEs gab ein Problem beim Commit!\e[0m"

        elif [[ $commit_message =~ ^.{1,4}$ ]]; then #Die Commit Nachricht ist kürzer als 5 Zeichen
            echo -e "\e[33mDie Commit-Nachricht war zu kurz. Sie muss mindestens fünf Zeichen haben\e[0m"
            ((file_counter ++))
            continue

        else #Commit mit dem angegeben Text
            commit_messages[$((${#commit_messages[@]} + 1 ))]="$commit_message" #Den aktuellen Commit ins Array packen
            last_commit_message=$commit_message
	        git commit -s "$file" -m "$commit_message" || echo -e "\e[31mEs gab ein Problem beim Commit!\e[0m"
        fi


        ((file_counter ++))
        changed=true
    done


    unset commit_messages #Das Array mit den Commitnachrichten wieder leeren


    #Prüfen, ob Commits angegeben wurden
    if [ "$changed" = false ]; then
        echo -e "\e[1;96m"; center "Keine Änderungen"; echo -e "\n\e[0m"
        echo -e "\e[31mEs wurden keine neuen Commits angegeben\e[0m"
    fi
}


push(){
    #Hier geht es drum alle Änderungen zu pushen
    read -e answer
    if [[ $answer =~ ^[YyJj]$ ]]; then
        output=$(git push 2>&1)
        if [[ $? == 0 ]]; then
            echo -e "\e[32mDie Commits wurden hochgeladen\e[0m"
        elif [[ $output == *"git pull"* ]]; then
            echo -e "\n\e[33mDas Repository muss erst gemergt werden\e[0m"
            sleep 1
            git pull --rebase 2>/dev/null >/dev/null
            git push
            echo -e "\e[32mDie Commits wurden hochgeladen\e[0m"
        elif [[ $output == *"--set-upstream"* ]]; then
            echo -e "\e[33mDer Upsteam musste erst gesetzt werden\e[0m"
            $(git push 2>&1 | grep "git push")
        else
            echo -e "\e[31mEs gab ein Problem beim Hochladen!\e[0m"
        fi
    else
        echo -e "\e[33mDie Änderungen werden nicht hochgeladen\e[0m"
    fi
}


pull(){
    #Prüfen, ob es Änderungen gibt, die noch gepullt werden müssen
    [[ $1 == "p" ]] && git remote update >/dev/null 2>/dev/null #Nur Wenn diff mit "p" gestartet wurde soll auf Commits geprüft werden, sonst nicht, da es zu lange dauert
    git_status=$(git status 2>&1)

    if [[ "$git_status" =~ (Commit hinter|Commits hinter|behind) ]]; then
	    amount=$(git status | sed '2!d' | sed 's/[^0-9]*//g')
        if [[ $amount == 1 ]]; then
            echo -e "\e[33mEs gibt noch einen Commit, der noch nicht heruntergeladen wurde. Soll er jetzt heruntergeladen werden?\e[0m"
        else
	        echo -e "\e[33mEs gibt noch $amount Commits, die noch nicht heruntergerladen wurden. Sollen sie jetzt heruntergeladen werden?\e[0m"
        fi
        read -e answer
        if [[ $answer =~ ^[YyJj]$ ]]; then
            git pull --rebase && echo -e "\e[32mDie Änderungen wurden heruntergeladen\n\e[0m" || echo -e "\e[31mEs gab ein Problem beim Herunterladen!\n\e[0m"
        else
            echo -e "\e[33mDie Änderungen werden nicht heruntergeladen\n\e[0m"
        fi
    fi
    return
}


diff_function(){

    [[ ${1} == "diff" ]] && cd "$(dirname "$(readlink -f "$BASH_SOURCE")")"

    git_status=$(git status 2>&1)

    if ! check_if_repo_exists; then return; fi

    if ! check_for_unmanaged_files; then git status && return; fi


    [[ $@ =~ (p|diff) ]] && pull p || pull


    branch=$(git branch | grep "*" | cut -d" " -f2-)


    #Veränderte Files finden und je nach Anzahl verschiedene Verhalten starten
    files=$(git status | grep "geändert\|modified\|neue Datei\|new file" | cut -d ":" -f2- | sed 's/^ *//g' | sed 's/ /}/g')
    case $(echo $files | wc -w ) in
        0) #Es wurden keine Dateien verändert; gibt es noch Commits, die nicht hochgeladen wurden?
            echo -e "\e[32mEs wurden keine Dateien modifiziert\e[0m"
            if [[ "$git_status" =~ (Commit vor|Commits vor| ahead) ]]; then
                echo -e "\e[1;96m"; center "Push"; echo -e "\n\e[0m"
                amount=$(git status | sed '2!d' | sed 's/[^0-9]*//g')
                if [[ $amount == 1 ]]; then
                    echo -e "\e[33mEs gibt noch einen Commit, der noch nicht hochgeladen wurde. Soll er jetzt hochgeladen werden?\e[0m"
                    git log origin/$branch..$branch | sed -n 5p
                else
                    number_of_duplicates=$(( $amount - $(git log origin/$branch..$branch | grep -v "^Merge\|^Author\|^Date\|Signed-off-by" | egrep -v [a-z0-9]{40} | sed '/^[[:space:]]*$/d' | awk '!x[$0]++' | wc -l) )) >/dev/null #Alle minus die nicht doppelten
                    if [[ $number_of_duplicates == 1 ]]; then
                        echo -e "\e[33mEs gibt noch $amount Commits (1 doppelter), die noch nicht hochgeladen wurden. Sollen sie jetzt hochgeladen werden?\e[0m"
                    else
                        echo -e "\e[33mEs gibt noch $amount Commits ($number_of_duplicates doppelte), die noch nicht hochgeladen wurden. Sollen sie jetzt hochgeladen werden?\e[0m"
                    fi
                    git log origin/$branch..$branch | grep -v "^Merge\|^Author\|^Date\|Signed-off-by" | egrep -v [a-z0-9]{40} | sed '/^[[:space:]]*$/d' | awk '!x[$0]++' | nl
                fi
                push
                return
            fi
            return;;
        1) echo -e "\e[1;96m\nEs wurde eine Datei modifiziert\e[0m";;
        *) echo -e "\e[1;96m\nEs wurden $(echo $files | wc -w ) Dateien modifiziert\e[0m";;
    esac


    if ! commit_files; then return; fi


    git_status=$(git status 2>&1)

    if [[ "$git_status" =~ (Commit vor |Commits vor| ahead) ]]; then
        echo -e "\e[1;96m"; center "Push"; echo -e "\n\e[0m"

        if [[ $(git log origin/$branch..$branch | grep -v "^Merge\|^Author\|^Date\|Signed-off-by" | egrep -v [a-z0-9]{40} | sed '/^[[:space:]]*$/d' | awk '!x[$0]++' | wc -l) == 1 ]]; then #Doppelte Commits sollen nicht doppelt gerechnet werden
            echo -e "\e[32mSoll die Änderung gepusht werden?\e[0m"
            git log origin/$branch..$branch | sed -n 5p
        else
            echo -e "\e[32mSollen die Änderungen gepusht werden?\e[0m"
            git log origin/$branch..$branch | grep -v "^Merge\|^Author\|^Date\|Signed-off-by" | egrep -v [a-z0-9]{40} | sed '/^[[:space:]]*$/d' | awk '!x[$0]++' | nl
        fi
        push
    fi

    return 0

}

complete -W "diff pull" diff

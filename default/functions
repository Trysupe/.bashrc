#!/bin/bash

cd(){
    # Macht ein normales cd, wenn ein Verzeichnis angegeben wurde
    # Schneidet den Dateinamen ab, wenn ein Verzeichnis mit folgendem Dateinamen angegeben wurde
    # Beispiel:
    # ┌─[11:40:57]-[:)]-[fschneider@frank]-[/tmp/]
    # └──> cd Resources/305075061F05.xml
    #
    # ┌─[11:41:03]-[:)]-[fschneider@frank]-[/tmp/Resources/]
    # └──>

    [[ ${1} == "--" ]] && shift

    [[ ${#} -gt 1 ]] && echo -e "\e[31mEs wurden zu viele Argumente angegeben\e[0m" && return 1

    local targetDirectory
    [[ -z ${1} ]] && targetDirectory=${HOME} || targetDirectory=${1} # Bei keiner Angabe ins Homeverzeichnis wechseln

    local fileToBeChecked
    [[ ${1} == "/"* ]] && fileToBeChecked="${1}" || fileToBeChecked="$(pwd)/${1}" # Check, ob ein absoluter Pfad angegeben wurde

    [[ -f ${fileToBeChecked} ]] && targetDirectory=$(dirname ${1})

    command cd "${targetDirectory}"
}

file_info(){
    [[ -z ${1} ]] && echo -e "\e[31mEs wurde kein Dateiname angegeben\e[0m" && return 1

    [[ ${1} == "." ]] && allFiles=$(find . -type f -not -path "*/\.git/*") || allFiles="${@}"

    local counter=0
    local amountOfFiles=$(echo ${allFiles} | wc -w)

	for file in ${allFiles}; do
		((counter++))

		[[ -d ${file} ]] && echo -e "\e[31m\"${file}\" ist ein Ordner\e[0m"             && continue
		[[ -f ${file} ]] || echo -e "\e[31mDie Datei \"${file}\" exisitiert nicht\e[0m" && continue

    	filename=$(basename ${file})
        echo -e "\e[1;96mDateiname:\t${filename}\e[0m"
        absolutePath=$(realpath ${file})
        echo -e "Absoluter Pfad:\t${absolutePath}"
    	echo -e "Größe:\t\t$(du -h ${file} | cut -f1)"
    	echo -e "Anzahl Zeilen:\t$(cat ${file} | wc -l | sed ':a;s/\B[0-9]\{3\}\>/.&/;ta')" #sed baut Tausender-Punkte ein
    	echo -e "Modifiziert:\t$(find ${file} -printf "%CH:%CM:%.2CS Uhr, %Cd.%Cm.%CY (%CA)")"
    	echo -e "Besitzer:\t$(find ${file} -printf "%u")"
    	echo -e "Gruppe:\t\t$(find ${file} -printf "%g")"
    	echo -e "Rechte:\t\t$(find ${file} -printf "%M (%m)" | cut -c 2-)"

    	[[ "${filename}" =~ ^\..{1,} ]] && fileHidden="Ja" ||  fileHidden="Nein"
        echo -e "Versteckt:\t${fileHidden}"

        if [[ $(file ${file}) == *"CRLF"* ]]; then
            [[ "${absolutePath##*.}" == "sh" ]] && lineEndings="\e[31mCRLF\e[0m" || lineEndings="CRLF"
        else
            lineEndings="LF"
        fi
    	echo -e "Zeilenenden:\t${lineEndings}"

        [[ "${amountOfFiles}" -gt "${counter}" ]] && echo -e "\n\n"
    done

    return 0
}

git_history(){
    local urlOfRepository=$(git_base_url)
    [[ -z ${urlOfRepository} ]] && return 1 #Stoppen, falls es sich nicht um ein Git-Repo handelt

    local space=" "
    local onlyCommitUrl=false
    if [[ ${1} == "-u" ]]; then
        local onlyCommitUrl=true
        space=""
        shift
    fi

    local urlOfHistoryOfRepository="${urlOfRepository}/commits"

    if [[ ! ${1} =~ [0-9]+ ]]; then
        echo -e "History URL: \e[96m${urlOfHistoryOfRepository}\e[0m"

        local typeOfSession=$(is_session_ssh)
        [[ ${typeOfSession} != "ssh" && $(command -v "xdg-open" 2>/dev/null) != "" ]] && xdg-open "${urlOfHistoryOfRepository}"
        return 0

    else
        [[ ${onlyCommitUrl} == false ]] && echo -e "History URL: ${urlOfHistoryOfRepository}"
    fi

    local commitHash

    if [[ ${1} =~ ^[0-9]{1,5}$ ]]; then
        local amountOfCommitsInRepository=$(git rev-list --count HEAD)
        local nthCommitToBeShown=$(( ${1} - 1 ))
        [[ ${nthCommitToBeShown} -gt ${amountOfCommitsInRepository} ]] && echo -e "\e[31mEs gibt nur ${amountOfCommitsInRepository} Commits in dieses Repo! \e[0m" && return 1

        commithash=$(git log -1 HEAD~${nthCommitToBeShown} --pretty="%H")
    else
        commithash=$(git rev-parse ${1} 2>/dev/null) #Langen Commithash zum kurzen Input bekommen
        if [[ ${?} != 0 ]]; then
            echo -e "\e[31mEs konnte kein Commit zu dem Hash gefunden werden\e[0m"
            return 1
        fi
    fi

    local urlOfCommit="${urlOfRepository}/commit/${commithash}"

    echo -e "Commit URL: ${space}\e[96m${urlOfCommit}\e[0m"
}

git_issues(){
    local urlOfRepository=$(git_base_url)
    [[ -z ${urlOfRepository} ]] && return 1 #Stoppen, falls es sich nicht um ein Git-Repo handelt

    local typeOfSession=$(is_session_ssh)

    local urlOfIssues="${urlOfRepository}""/issues/"

    echo -e "URL: \e[96m${urlOfIssues}\e[0m"

    [[ ${typeOfSession} != "ssh" && $(command -v "xdg-open" 2>/dev/null) != "" ]] && xdg-open "${urlOfIssues}"

    return 0
}

git_log(){
    if ! check_if_git_repo_exists; then return 1; fi

    [[ $(git_url -u) == *"abm-local.de"* ]] && repo="abm" || repo=""

    local commitcount="30"
    local diff=""

    [[ -n ${1} ]] && commitcount="${1}"
    [[ -n ${2} ]] && diff="${2}"

    local amountOfCommitsInRepository=$(git rev-list --count HEAD)

    if [[ ${amountOfCommitsInRepository} -lt ${commitcount} ]]; then
        echo -e "\e[33mEs gibt nur ${amountOfCommitsInRepository} Commits in dieses Repo! \e[0m"
        commitcount=${amountOfCommitsInRepository}
    fi

    IFS=$'\n'
    if [[ ${commitcount} == 1 ]]; then
        read -d $'\0' -a hashandtime   <<< $(git --no-pager log -n${commitcount} --reverse ${diff} --pretty="    %cd | %h | " --date=format:"%a | %d.%m. | %H:%M:%S")
    else
        read -d $'\0' -a hashandtime   <<< $(git --no-pager log -n${commitcount} --reverse ${diff} --pretty="| %cd | %h | " --date=format:"%a | %d.%m. | %H:%M:%S" | nl)
    fi
    read -d $'\0' -a commitauthor      <<< $(git --no-pager log -n${commitcount} --reverse ${diff} --pretty="%ae" | cut -c -2 | tr a-z A-Z)
    read -d $'\0' -a statsofcommits    <<< $(git --no-pager log -n${commitcount} --reverse ${diff} --pretty="%h§" --shortstat | sed -z 's/§\n\n//g') #TODO: sed entfernen da langsam
    read -d $'\0' -a messagesofcommits <<< $(git --no-pager log -n${commitcount} --reverse ${diff} --pretty=" %s")

    local linecounter=0
    local max_files_changed=0
    local max_insertions=0
    local max_deletions=0

    # Wenn kein "changed" in der Zeile ist, handelt es sich wahrscheinlich um einen Merge und das
    # "files changed" wird von git nicht ausgegeben, somit muss es erst per git diff geholt werden
    # &
    # Maxmimale Anzahl geänderter Files, Insertions & Deletions herausfinden
    for line in "${statsofcommits[@]}"; do
        local newline
        if [[ ${line} == *changed* ]]; then
            newline=$(echo ${line} | cut -d " " -f2-)
        else
            local hash=$(echo ${line} | sed 's/§//')
            newline="$(git diff ${hash}^ ${hash} --stat | grep "changed,")"
        fi

        local files_changed=$(echo ${newline} | grep -Eo '[0-9]+' | head -1)
        local insertions=0
        [[ ${newline} == *"insertion"* ]] && insertions=$(echo ${newline} | grep -Eo '[0-9]+' | sed -n 2p)
        local deletions=0
        [[ ${newline} == *"deletion"* ]] && deletions=$(echo ${newline} | grep -Eo '[0-9]+' | tail -1)

        statsofcommits[${linecounter}]="${files_changed} ${insertions} ${deletions}"

        [[ ${files_changed} -gt ${max_files_changed} ]] && max_files_changed=${files_changed}
        [[ ${insertions}    -gt ${max_insertions}    ]] && max_insertions=${insertions}
        [[ ${deletions}     -gt ${max_deletions}     ]] && max_deletions=${deletions}
        ((linecounter++))
        echo -ne "Log wird geparsed (${linecounter}/${commitcount})\r"
    done

    echo -ne "                                               \r" #"Log wird geparsed" überschreiben

    local len_of_max_files_changed=$(echo ${max_files_changed} | wc -c)
       local len_of_max_insertions=$(echo ${max_insertions}    | wc -c)
        local len_of_max_deletions=$(echo ${max_deletions}     | wc -c)

    ((len_of_max_files_changed--)) #wc -w is +1, aber nur bei len_of_max_files_changed 1 abziehen, da die anderen noch "+" & "-" haben

    linecounter=0
    for line in "${hashandtime[@]}"; do #Ausgabe der ganzen Infos
        echo -n ${line}
        [[ ${repo} == "abm" ]] && echo -n "${commitauthor[${linecounter}]} | "
        local statsline=${statsofcommits[${linecounter}]}

        local files_changed=$(echo ${statsline} | cut -d " " -f1)
           local insertions=$(echo ${statsline} | cut -d " " -f2)
            local deletions=$(echo ${statsline} | cut -d " " -f3)

        printf "%${len_of_max_files_changed}s" "${files_changed}"
        printf " (\e[32m%${len_of_max_insertions}s\e[0m" "+${insertions}"
        printf " \e[31m%${len_of_max_deletions}s\e[0m)" "-${deletions}"
        echo -e " |""$(echo ${messagesofcommits[${linecounter}]})"
        ((linecounter++))
    done

    [[ -n ${diff} ]] && return

    while true; do
        echo -e "\n\e[96;1m"
        center "Soll ein Commit angezeigt werden?"
        echo -e "\e[0m"
        read -e answer
        [[ -z ${answer} ]] && break
        local commithash
        if [[ ${answer} =~ ^[0-9]{1,2}$ && ${answer} -le 30  ]]; then
            commithash=$(git --no-pager log -n 30 --reverse --pretty="%h" | sed -n ${answer}p)
        elif [[ ${answer} =~ ^[0-9a-z]{5,}$ ]]; then
            commithash=${answer}
        else
            echo -e "\e[31mDie Antwort konnte nicht interpretiert werden\e[0m"
            continue
        fi
        git show ${commithash}
    done
}

git_url(){
    local urlOfRepository=$(git_base_url)
    [[ -z ${urlOfRepository} ]] && return 1 #Stoppen, falls es sich nicht um ein Git-Repo handelt

    local typeOfSession=$(is_session_ssh)

    local aktiveGitBranch=$(git rev-parse --abbrev-ref HEAD 2>&1)

    echo -e "Repository URL: \e[96m${urlOfRepository}\e[0m"
    [[ ${typeOfSession} != "ssh" && $(command -v "xdg-open" 2>/dev/null) != "" && ${1} != "-u" ]] && xdg-open "${urlOfRepository}"
}

printarray(){
    [[ -n ${1} ]]        && echo -e "\e[33mAchtung das array muss \"foo\" heißen!" && return 1
    [ ${#foo[@]} -eq 0 ] && echo -e "\e[31mDas Array \"foo\"ist leer!"             && return 1

    echo -e "\e[96;1m"; center "Ohne Index"; echo -e "\e[0m"
    for i in "${!foo[@]}"; do
        printf "%s\n" "${foo[${i}]}"
    done

    echo -e "\n\e[96;1m"; center "Mit Index"; echo -e "\e[0m"
    for i in "${!foo[@]}"; do
        printf "%s\t%s\n" "${i}" "${foo[${i}]}"
    done
}

repeat(){
    [ ${#} -gt 2 ] && echo -e "\e[31mEs wurden zu viele Argumente angegeben\e[0m" && return 1

    [[ -z ${2} ]]  && sleeptime="1.0" || sleeptime=$(echo ${2} | sed 's/,/./')

    local counter=0
    while (true); do
        ((counter ++))

        header="   $(date +%T)   |   Durchlauf: ${counter}   |   Alle $(echo ${sleeptime} | sed 's/\./,/')s   |   Kommando: ${1}   "
        [ "${#header}" -ge "$(tput cols)" ] && header="   $(date +%T)   |   Durchlauf: ${counter}   |   Alle $(echo ${sleeptime} | sed 's/\./,/')s   "
        echo -e "\n\e[96;1m"; center "${header}"; echo -e "\e[0m"

        eval "${1}"
        read -t ${sleeptime}
    done
}

sa(){
    [[ -z ${1} ]]    && echo -e "\e[31mEs wurde kein Name angegeben\e[0m"           && return 1
    [[ -f ${1} ]]    && echo -e "\e[31mDie Datei exisitiert bereits\e[0m"           && return 1
    [[ ${#} -gt 1 ]] && echo -e "\e[31mEs wurden zu viele Argumente angegeben\e[0m" && return 1

    filename="${1}"
    touch ${filename}
    chmod +x ${filename}

    if [[ ${filename} == *".sh" ]]; then
        echo -e "#!/bin/bash\n\n" >> ${filename}

    elif [[ ${filename} == *".py" ]]; then
        echo -e "#!/usr/bin/python3\n# -*- coding: utf-8 -*-\n\n" >> ${filename}

    fi

    [[ -n $(command -v code) ]] && code ${filename} || nano +8 ${filename}

    echo -e "\e[32mSoll das Script ausgeführt werden?\e[0m"
    read -e -n1 answer
    if [[ ${answer} =~ ^[YyJj]$ ]]; then
        if [[ -f ${filename} ]]; then
            echo -e "\e[1;96m"; center "${filename}"; echo -e "\n\e[0m"
            ./${filename}

        else
            echo -e "\e[31mDas Script existiert nicht mehr!\e[0m"
            return 1

        fi

    else
        echo -e "\e[33mDas Script wird nicht ausgeführt\e[0m"
        return 1
    fi
}

search_string(){
    [[ -z ${1} ]]    && echo -e "\e[31mEs wurde kein Suchbegriff angegeben\e[0m"    && return 1
    [[ ${#} -gt 2 ]] && echo -e "\e[31mEs wurden zu viele Argumente angegeben\e[0m" && return 1

    if [[ ${#} == 1 ]]; then
        grep -inrs --color=always "${1}" ./*    || echo -e "\e[33mEs wurden keine Sucherergbnisse gefunden\e[0m"
    else
        grep -inrs --color=always "${1}" "${2}" || echo -e "\e[33mEs wurden keine Sucherergbnisse gefunden\e[0m"
    fi
}

search_file(){
    [[ -z ${1} ]] && echo -e "\e[31mEs wurde kein Suchbegriff angegeben\e[0m"      && return 1

    #grep, um eine Fehlermeldung bei keinen Suchergebnissen anzeigen zu können und die Fundorte farbig zu markieren
    if [[ ${#} == 1 ]]; then
        if [[ -n $(find . -maxdepth 1 -type d -iname "customers") && $(hostname) == "frank" ]]; then #Ausnahme für frank
            echo -e "\e[33mSoll auch im customers-Ordner gesucht werden?\e[0m"
            read -e -n1 answer
            if [[ ${answer} =~ ^[YyJj]$ ]]; then
                find . -iname "*${1}*"                            -not -path "*/\.git/*" | grep -i "${1}" --color=always || echo -e "\e[33mEs wurden keine Sucherergbnisse gefunden\e[0m"

            else
                find . -iname "*${1}*" -not -path "./customers/*" -not -path "*/\.git/*" | grep -i "${1}" --color=always || echo -e "\e[33mEs wurden keine Sucherergbnisse gefunden\e[0m"

            fi

        else
            find . -iname "*${1}*" -not -path "*/\.git/*" | grep -i "${1}" --color=always || echo -e "\e[33mEs wurden keine Sucherergbnisse gefunden\e[0m"

        fi
    else
        local fileToSearchFor=${1}
        shift
        find "${@}" -iname "*${fileToSearchFor}*" -not -path "*/\.git/*" | grep -i "${fileToSearchFor}" --color=always || echo -e "\e[33mEs wurden keine Sucherergbnisse gefunden\e[0m"
    fi
}

stopwatch(){
    [ ${#} -lt 1 ] && echo -e "\e[31mEs wurde kein Befehl angegeben\e[0m" && return 1

    local commandToRun="$(echo ${@} | sed 's/"/\\"/g')"

    local startOfExecution=$(date +%s,%N)

    eval "${commandToRun}"

    local endOfExecution=$(date +%s,%N)

    local secondsSinceEpochTillStartOfExecutions=$(echo ${startOfExecution} | cut -d',' -f1)
    local nanosecondsAtStartOfExecutions=$(echo ${startOfExecution} | cut -d',' -f2)
    local secondsSinceEpochTillEndOfExecutions=$(echo ${endOfExecution} | cut -d',' -f1)
    local nanosecondsAtEndOfExecutions=$(echo ${endOfExecution} | cut -d',' -f2)

    local duration="0""$(bc <<< "scale=3; ${secondsSinceEpochTillEndOfExecutions} - ${secondsSinceEpochTillStartOfExecutions} + (${nanosecondsAtEndOfExecutions} -${nanosecondsAtStartOfExecutions})/1000000000")"

    echo -e "\e[1m\n\e[36mDas Auführen hat $(date -u --date @${duration} +%M:%S.%3N) gedauert"
}

tmux_help(){
    echo -e "\e[1;36m"; center "TMUX Hilfe"; echo -e "\n\e[0m" \
    "\nStartkommando:         <\e[1;36mSTRG\e[0m> + <\e[1;36mB\e[0m>\n" \
    "\nTeilen:" \
    "\n    - Horizontal:      <\e[1;36m%\e[0m>" \
    "\n    - Vertikal:        <\e[1;36m\"\e[0m>\n" \
    "\nPanes:" \
    "\n    - Layout wechseln: <\e[1;36mSpace\e[0m>    - Nächstes:            <\e[1;36mO\e[0m>" \
    "\n    - Maximieren:      <\e[1;36mZ\e[0m>        - Panenummer anzeigen: <\e[1;36mQ\e[0m>" \
    "\n    - Schließen:       <\e[1;36mX\e[0m>        - Zu Pane wechseln:    <\e[1;36mQ\e[0m> + <\e[1;36m0-9\e[0m>" \
    "\n                                  - Alternativ:          <\e[1;36mPfeiltasten\e[0m>\n" \
    "\nEinfügen: <\e[1;36mShift\e[0m> + <\e[1;36mMittlere Maustaste\e[0m>"
}

to_lf(){
    [[ -z ${1} ]] && echo -e "\e[31mEs wurde keine Datei, die umgewandelt werden soll, angegeben\e[0m" && return 1

    if [[ "${1}" == "alle" ]]; then
        allFiles=$(find . -type f -not -path "*/\.git/*" | xargs file | grep "CRLF" | cut -d " " -f1 | cut -d ":" -f1)

        [[ -z ${allFiles} ]] && echo -e "\e[33mEs wurde keine Datei, die CRLF Dateienden hat\e[0m" && return

        echo -e "\e[96mSollen die folgenden Dateien zu LF konvertiert werden?\e[0m\n$(echo ${allFiles} | sed 's/ /\n/g' | nl)\n"

        read -e -n1 answer
        [[ ! ${answer} =~ (Y|y|J|j) ]] && return

    else
        allFiles=${@}

    fi

    for file in ${allFiles}; do

        [[ "$(file ${file})" == *"CRLF"* ]] && lineEndings="\e[31mCRLF" || lineEndings="\e[32mLF"

        echo -e "Ändere die Zeilenenden zu LF von \e[96;1m${file}\e[0m\n    War davor: ${lineEndings}\e[0m"

        tr -d '\015' <${file} >"${file}""_new"
        mv "${file}""_new" ${file}
    done
}

complete -F _longopt -W "alle" to_lf

upgrade(){
    echo -e "\e[1;96mAPT wird aufgerufen\n\e[0m"

    sudo apt upgrade ${1} #Falls -y angegeben wurde
    [[ ${?} == 0 ]] || return
    echo -e "\n\e[32mUpdates Abgeschlossen\e[0m"

    if [[ $(hostname) != "openhab" ]]; then
        return
    fi

    openHABIP="localhost"
    itemToBeUpdated="System_Updates"
    newState="0"
    curl -X PUT --header "Content-Type: text/plain" --header "Accept: application/json" -d "${newState}" "http://${openHABIP}:8080/rest/items/${itemToBeUpdated}/state"
    echo -e "\e[1;96mDie Anzahl der Updates wurde aktualisiert\e[0m"
}

which(){
    [[ -z ${1} ]]    && echo -e "\e[31mEs wurde kein Programm angegeben\e[0m"       && return 1
    [[ ${#} -gt 2 ]] && echo -e "\e[31mEs wurden zu viele Argumente angegeben\e[0m" && return 1

    type ${1}

    local isFunction=$(type ${1})
    local fileLocation=$(bash -c "which ${1}")

    if [[ ( ! ${isFunction} == *"ist eine Funktion"* ) && -n ${fileLocation} ]]; then

        if [[ $(file -L ${fileLocation}) =~ (ASCII|script) ]]; then
            echo -e "\nSoll der Sourcecode angezeigt werden? \e[2m(J/N)\e[0m"
            read -e -n1 answer

            [[ ${answer} =~ ^[YyJj]$ ]] && less ${fileLocation}

        else
            #Nicht anzeigen, wenn es sich um einen Alias handelt
            [[ ${isFunction} == *"Alias"* ]] || echo -e "\nEs handelt sich um eine Binärdatei"

        fi
    fi
    return 0
}
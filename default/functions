#!/bin/bash

cd(){
    # Macht ein normales cd, wenn ein Verzeichnis angegeben wurde
    # Schneidet den Dateinamen ab, wenn ein Verzeichnis mit folgendem Dateinamen angegeben wurde
    # Beispiel:
    # ┌─[11:40:57]-[:)]-[fschneider@frank]-[/tmp/]
    # cd Resources/305075061F05.xml
    #
    # ┌─[11:41:03]-[:)]-[fschneider@frank]-[/tmp/Resources/]
    # └──>

    [[ ${1} == "--" ]] && shift

    [[ ${#} -gt 1 ]] && echo -e "\e[31mEs wurden zu viele Argumente angegeben\e[0m" && return 1

    local targetDirectory
    [[ -z ${1} ]] && targetDirectory=${HOME} || targetDirectory=${1} # Bei keiner Angabe ins Homeverzeichnis wechseln

    local fileToBeChecked
    [[ ${1} == "/"* ]] && fileToBeChecked="${1}" || fileToBeChecked="$(pwd)/${1}" # Check, ob ein absoluter Pfad angegeben wurde

    [[ -f ${fileToBeChecked} ]] && targetDirectory=$(dirname ${1})

    command cd "${targetDirectory}"
}

file_info(){
    [[ -z ${1} ]] && echo -e "\e[31mEs wurde kein Dateiname angegeben\e[0m" && return 1

    [[ ${1} == "." ]] && allFiles=$(find . -type f -not -path "*/\.git/*") || allFiles="${@}"

    local counter=0
    local amountOfFiles=$(echo ${allFiles} | wc -w)

	for file in ${allFiles}; do
		((counter++))

		[[ -d ${file} ]]   && echo -e "\e[31m\"${file}\" ist ein Ordner\e[0m"             && continue
		[[ ! -f ${file} ]] && echo -e "\e[31mDie Datei \"${file}\" exisitiert nicht\e[0m" && continue

    	filename=$(basename ${file})
        echo -e "\e[1;96mDateiname:\t${filename}\e[0m"
        absolutePath=$(realpath ${file})
        echo -e "Absoluter Pfad:\t${absolutePath}"
    	echo -e "Größe:\t\t$(du -h ${file} | cut -f1)"
    	echo -e "Anzahl Zeilen:\t$(cat ${file} | wc -l | sed ':a;s/\B[0-9]\{3\}\>/.&/;ta')" #sed baut Tausender-Punkte ein
    	echo -e "Modifiziert:\t$(find ${file} -printf "%CH:%CM:%.2CS Uhr, %Cd.%Cm.%CY (%CA)")"
    	echo -e "Besitzer:\t$(find ${file} -printf "%u")"
    	echo -e "Gruppe:\t\t$(find ${file} -printf "%g")"
    	echo -e "Rechte:\t\t$(find ${file} -printf "%M (%m)" | cut -c 2-)"

    	[[ "${filename}" =~ ^\..{1,} ]] && fileHidden="Ja" || fileHidden="Nein"
        echo -e "Versteckt:\t${fileHidden}"

        if [[ $(file ${file}) == *"CRLF"* ]]; then
            [[ "${absolutePath##*.}" == "sh" ]] && lineEndings="\e[31mCRLF\e[0m" || lineEndings="CRLF"
        else
            lineEndings="LF"
        fi
    	echo -e "Zeilenenden:\t${lineEndings}"

        [[ "${amountOfFiles}" -gt "${counter}" ]] && echo -e "\n\n"
    done

    return 0
}

git_history(){
    local urlOfRepository=$(git_base_url)
    [[ -z ${urlOfRepository} ]] && return 1 #Stoppen, falls es sich nicht um ein Git-Repo handelt

    local space=" "
    local onlyCommitUrl=false
    if [[ ${1} == "-u" ]]; then
        local onlyCommitUrl=true
        space=""
        shift
    fi

    local urlOfHistoryOfRepository="${urlOfRepository}/commits"

    if [[ ! ${1} =~ [0-9]+ ]]; then
        echo -e "History URL: \e[96m${urlOfHistoryOfRepository}\e[0m"

        local typeOfSession=$(is_session_ssh)
        [[ ${typeOfSession} != "ssh" && $(command -v "xdg-open" 2>/dev/null) != "" ]] && xdg-open "${urlOfHistoryOfRepository}"
        return 0

    else
        [[ ${onlyCommitUrl} == false ]] && echo -e "History URL: ${urlOfHistoryOfRepository}"
    fi

    local commitHash

    if [[ ${1} =~ ^[0-9]{1,5}$ ]]; then
        local amountOfCommitsInRepository=$(git rev-list --count HEAD)
        local nthCommitToBeShown=$(( ${1} - 1 ))
        [[ ${nthCommitToBeShown} -gt ${amountOfCommitsInRepository} ]] && echo -e "\e[31mEs gibt nur ${amountOfCommitsInRepository} Commits in diesem Repo! \e[0m" && return 1

        commitHash=$(git log -1 HEAD~${nthCommitToBeShown} --pretty="%H")
    else
        commitHash=$(git rev-parse ${1} 2>/dev/null) #Langen Commithash zum kurzen Input bekommen
        if [[ ${?} != 0 ]]; then
            echo -e "\e[31mEs konnte kein Commit zu dem Hash gefunden werden\e[0m"
            return 1
        fi
    fi

    local urlOfCommit="${urlOfRepository}/commit/${commitHash}"

    echo -e "Commit URL: ${space}\e[96m${urlOfCommit}\e[0m"
}

git_issues(){
    local urlOfRepository=$(git_base_url)
    [[ -z ${urlOfRepository} ]] && return 1 #Stoppen, falls es sich nicht um ein Git-Repo handelt

    local typeOfSession=$(is_session_ssh)

    local urlOfIssues="${urlOfRepository}""/issues/"

    echo -e "URL: \e[96m${urlOfIssues}\e[0m"

    [[ ${typeOfSession} != "ssh" && $(command -v "xdg-open" 2>/dev/null) != "" ]] && xdg-open "${urlOfIssues}"

    return 0
}

git_last_pull(){
    if ! check_if_git_repo_exists; then return 1; fi

    local fetchHeadFile=$(git rev-parse --show-toplevel)/.git/FETCH_HEAD

    [[ ! -f ${fetchHeadFile} ]] && return # Check if file exsits

    local pullDate=$(date -r ${fetchHeadFile} +%D)
    local pullTime=$(date -r ${fetchHeadFile} +'%H:%M:%S Uhr')

    if [[ ${pullDate} == $(date +%D) ]]; then
        echo -n "Der letzte Pull war heute"
    elif [[ ${pullDate} == $(date +%D --date="1 day ago") ]]; then
        echo -n "Der letzte Pull war gestern"
    else
        daysSince=$(( ($(date +%s) - $(date --date=${pullDate} +%s) )/(60*60*24) ))
        echo -n "Der letzte Pull war vor ${daysSince} Tagen am $(date -r ${fetchHeadFile} +'am %A, den %d.%m.')"
    fi
    echo " um ${pullTime}"

    return 0
}

git_log(){
    if ! check_if_git_repo_exists; then return 1; fi

    [[ $(git_url -u) == *"abm-local.de"* ]] && repo="abm" || repo=""

    local amountOfCommits="30"
    local commitsOfBranchToShow="" # Argument supplied by default/diff/function that supplies what commits to show (..origin/${branch}"

    [[ -n ${1} ]] && amountOfCommits="${1}"
    [[ -n ${2} ]] && commitsOfBranchToShow="${2}"

    local amountOfCommitsInRepository=$(git rev-list --count HEAD)

    if [[ ${amountOfCommitsInRepository} -lt ${amountOfCommits} ]]; then
        echo -e "\e[33mEs gibt nur ${amountOfCommitsInRepository} Commits in diesem Repo! \e[0m"
        amountOfCommits=${amountOfCommitsInRepository}
    fi

    IFS=$'\n'
    if [[ ${amountOfCommits} == 1 ]]; then
        read -d $'\0' -a hashandtime   <<< $(git --no-pager log -n${amountOfCommits} --reverse ${commitsOfBranchToShow} --pretty="    %ad | %h | " --date=format:"%a | %d.%m. | %H:%M:%S")
    else
        read -d $'\0' -a hashandtime   <<< $(git --no-pager log -n${amountOfCommits} --reverse ${commitsOfBranchToShow} --pretty="| %ad | %h | " --date=format:"%a | %d.%m. | %H:%M:%S" | nl)
    fi
    read -d $'\0' -a commitAuthor      <<< $(git --no-pager log -n${amountOfCommits} --reverse ${commitsOfBranchToShow} --pretty="%ae" | cut -c -2 | tr a-z A-Z)
    read -d $'\0' -a statsOfCommit     <<< $(git --no-pager log -n${amountOfCommits} --reverse ${commitsOfBranchToShow} --pretty="%h§" --shortstat | sed -z 's/§\n\n//g') #TODO: sed entfernen da langsam
    read -d $'\0' -a messageOfCommit   <<< $(git --no-pager log -n${amountOfCommits} --reverse ${commitsOfBranchToShow} --pretty=" %s")

    local lineCounter=0     # Holds the progress while iterating though the array
    local maxFilesChanged=0 # Saves the maximum ammount of files changed of all commits
    local maxInserions=0    # Saves the maximum ammount of intertions of all commits
    local maxDeletions=0    # Saves the maximum ammount of deletions of all commits

    # Maxmimale Anzahl geänderter Files, Insertions & Deletions herausfinden
    for line in "${statsOfCommit[@]}"; do
        local newline
        # If there is no "changed" in the line the commit is probably a merge commit from a MR
        # If so git doesn't show the usual "g files changed, h insertions(+), i deletions(-)" so it has to be fetched from git diff
        if [[ ${line} == *changed* ]]; then
            newline=$(echo ${line} | cut -d " " -f2-)
        else
            local hash=$(echo ${line} | sed 's/§//')
            newline="$(git diff ${hash}^ ${hash} --stat | grep "changed,")"
        fi

        local filesChanged=$(echo ${newline} | grep -Eo '[0-9]+' | head -1)
        local insertions=0
        [[ ${newline} == *"insertion"* ]] && insertions=$(echo ${newline} | grep -Eo '[0-9]+' | sed -n 2p)
        local deletions=0
        [[ ${newline} == *"deletion"* ]] && deletions=$(echo ${newline} | grep -Eo '[0-9]+' | tail -1)

        statsOfCommit[${lineCounter}]="${filesChanged} ${insertions} ${deletions}"

        [[ ${filesChanged} -gt ${maxFilesChanged} ]] && maxFilesChanged=${filesChanged}
        [[ ${insertions}   -gt ${maxInserions}    ]] && maxInserions=${insertions}
        [[ ${deletions}    -gt ${maxDeletions}    ]] && maxDeletions=${deletions}
        ((lineCounter++))
        echo -ne "Log wird geparsed (${lineCounter}/${amountOfCommits})\r"
    done

    echo -ne "                                               \r" #"Log wird geparsed" überschreiben

    local lenOfMaxFilesChanged=$(echo ${maxFilesChanged} | wc -c)
       local lenOfMaxInserions=$(echo ${maxInserions}    | wc -c)
       local lenOfMaxDeletions=$(echo ${maxDeletions}    | wc -c)

    ((lenOfMaxFilesChanged--)) #wc -w is +1, aber nur bei lenOfMaxFilesChanged 1 abziehen, da die anderen noch "+" & "-" haben

    lineCounter=0
    for line in "${hashandtime[@]}"; do #Ausgabe der ganzen Infos
        echo -n ${line}
        [[ ${repo} == "abm" ]] && echo -n "${commitAuthor[${lineCounter}]} | "
        local statsline=${statsOfCommit[${lineCounter}]}

        local filesChanged=$(echo ${statsline} | cut -d " " -f1)
          local insertions=$(echo ${statsline} | cut -d " " -f2)
           local deletions=$(echo ${statsline} | cut -d " " -f3)

        printf "%${lenOfMaxFilesChanged}s" "${filesChanged}"
        printf " (\e[32m%${lenOfMaxInserions}s\e[0m" "+${insertions}"
        printf " \e[31m%${lenOfMaxDeletions}s\e[0m)" "-${deletions}"
        echo -e " |""$(echo ${messageOfCommit[${lineCounter}]})"
        ((lineCounter++))
    done

    [[ -n ${commitsOfBranchToShow} ]] && return

    while true; do
        echo -e "\n\e[96;1m"
        center "Soll ein Commit angezeigt werden?"
        echo -e "\e[0m"
        read -e answer
        [[ -z ${answer} ]] && break
        local commitHash
        if [[ ${answer} =~ ^[0-9]{1,2}$ && ${answer} -le ${amountOfCommits} ]]; then
            commitHash=$(git --no-pager log -n 30 --reverse --pretty="%h" | sed -n ${answer}p)
        elif [[ ${answer} =~ ^[0-9a-z]{5,}$ ]]; then
            commitHash=${answer}
        else
            echo -e "\e[31mDie Antwort konnte nicht interpretiert werden\e[0m"
            continue
        fi
        git show ${commitHash}
    done
}

git_url(){
    local urlOfRepository=$(git_base_url)
    [[ -z ${urlOfRepository} ]] && return 1 #Stoppen, falls es sich nicht um ein Git-Repo handelt

    local typeOfSession=$(is_session_ssh)

    local aktiveGitBranch=$(git rev-parse --abbrev-ref HEAD 2>&1)

    echo -e "Repository URL: \e[96m${urlOfRepository}\e[0m"
    [[ ${typeOfSession} != "ssh" && $(command -v "xdg-open" 2>/dev/null) != "" && ${1} != "-u" ]] && xdg-open "${urlOfRepository}"
}

printarray(){
    [[ -n ${1} ]]        && echo -e "\e[33mAchtung das array muss \"foo\" heißen!" && return 1
    [ ${#foo[@]} -eq 0 ] && echo -e "\e[31mDas Array \"foo\"ist leer!"             && return 1

    echo -e "\e[96;1m"; center "Ohne Index"; echo -e "\e[0m"
    for i in "${!foo[@]}"; do
        printf "%s\n" "${foo[${i}]}"
    done

    echo -e "\n\e[96;1m"; center "Mit Index"; echo -e "\e[0m"
    for i in "${!foo[@]}"; do
        printf "%s\t%s\n" "${i}" "${foo[${i}]}"
    done
}

repeat(){
    [ ${#} -gt 2 ] && echo -e "\e[31mEs wurden zu viele Argumente angegeben\e[0m" && return 1

    [[ -z ${2} ]]  && sleeptime="1.0" || sleeptime=$(echo ${2} | sed 's/,/./')

    local counter=0
    while (true); do
        ((counter ++))

        header="   $(date +%T)   |   Durchlauf: ${counter}   |   Alle $(echo ${sleeptime} | sed 's/\./,/')s   |   Kommando: ${1}   "
        [ "${#header}" -ge "$(tput cols)" ] && header="   $(date +%T)   |   Durchlauf: ${counter}   |   Alle $(echo ${sleeptime} | sed 's/\./,/')s   "
        echo -e "\n\e[96;1m"; center "${header}"; echo -e "\e[0m"

        eval "${1}"
        read -t ${sleeptime}
    done
}

sa(){
    [[ -z ${1} ]]    && echo -e "\e[31mEs wurde kein Name angegeben\e[0m"           && return 1
    [[ -f ${1} ]]    && echo -e "\e[31mDie Datei exisitiert bereits\e[0m"           && return 1
    [[ ${#} -gt 1 ]] && echo -e "\e[31mEs wurden zu viele Argumente angegeben\e[0m" && return 1

    filename="${1}"
    touch ${filename}
    chmod +x ${filename}

    if [[ ${filename} == *".sh" ]]; then
        echo -e "#!/bin/bash\n\n" >> ${filename}

    elif [[ ${filename} == *".py" ]]; then
        echo -e "#!/usr/bin/python3\n# -*- coding: utf-8 -*-\n\n" >> ${filename}

    fi

    [[ -n $(command -v code) ]] && code ${filename} || nano +8 ${filename}

    echo -e "\e[32mSoll das Script ausgeführt werden?\e[0m"
    read -e -n1 answer
    if [[ ${answer} =~ ^[YyJj]$ ]]; then
        if [[ -f ${filename} ]]; then
            echo -e "\e[1;96m"; center "${filename}"; echo -e "\n\e[0m"
            ./${filename}

        else
            echo -e "\e[31mDas Script existiert nicht mehr!\e[0m"
            return 1

        fi

    else
        echo -e "\e[33mDas Script wird nicht ausgeführt\e[0m"
        return 1
    fi
}

search_string(){
    [[ -z ${1} ]]    && echo -e "\e[31mEs wurde kein Suchbegriff angegeben\e[0m"    && return 1
    [[ ${#} -gt 2 ]] && echo -e "\e[31mEs wurden zu viele Argumente angegeben\e[0m" && return 1

    if [[ ${#} == 1 ]]; then
        grep -inrs --color=always "${1}" ./*    || echo -e "\e[33mEs wurden keine Sucherergbnisse gefunden\e[0m"
    else
        grep -inrs --color=always "${1}" "${2}" || echo -e "\e[33mEs wurden keine Sucherergbnisse gefunden\e[0m"
    fi
}

search_file(){
    [[ -z ${1} ]] && echo -e "\e[31mEs wurde kein Suchbegriff angegeben\e[0m"      && return 1

    #grep, um eine Fehlermeldung bei keinen Suchergebnissen anzeigen zu können und die Fundorte farbig zu markieren
    if [[ ${#} == 1 ]]; then
        if [[ -n $(find . -maxdepth 1 -type d -iname "customers") && $(hostname) == "frank" ]]; then #Ausnahme für frank
            echo -e "\e[33mSoll auch im customers-Ordner gesucht werden?\e[0m"
            read -e -n1 answer
            if [[ ${answer} =~ ^[YyJj]$ ]]; then
                find . -iname "*${1}*"                            -not -path "*/\.git/*" | grep -i "${1}" --color=always || echo -e "\e[33mEs wurden keine Sucherergbnisse gefunden\e[0m"

            else
                find . -iname "*${1}*" -not -path "./customers/*" -not -path "*/\.git/*" | grep -i "${1}" --color=always || echo -e "\e[33mEs wurden keine Sucherergbnisse gefunden\e[0m"

            fi

        else
            find . -iname "*${1}*" -not -path "*/\.git/*" | grep -i "${1}" --color=always || echo -e "\e[33mEs wurden keine Sucherergbnisse gefunden\e[0m"

        fi
    else
        local fileToSearchFor=${1}
        shift
        find "${@}" -iname "*${fileToSearchFor}*" -not -path "*/\.git/*" | grep -i "${fileToSearchFor}" --color=always || echo -e "\e[33mEs wurden keine Sucherergbnisse gefunden\e[0m"
    fi
}

stopwatch(){
    [ ${#} -lt 1 ] && echo -e "\e[31mEs wurde kein Befehl angegeben\e[0m" && return 1

    local commandToRun="$(echo ${@} | sed 's/"/\\"/g')"

    local startOfExecution=$(date +%s,%N)

    eval "${commandToRun}"

    local endOfExecution=$(date +%s,%N)

    local secondsSinceEpochTillStartOfExecutions=$(echo ${startOfExecution} | cut -d',' -f1)
    local nanosecondsAtStartOfExecutions=$(echo ${startOfExecution} | cut -d',' -f2)
    local secondsSinceEpochTillEndOfExecutions=$(echo ${endOfExecution} | cut -d',' -f1)
    local nanosecondsAtEndOfExecutions=$(echo ${endOfExecution} | cut -d',' -f2)

    local duration="0""$(bc <<< "scale=3; ${secondsSinceEpochTillEndOfExecutions} - ${secondsSinceEpochTillStartOfExecutions} + (${nanosecondsAtEndOfExecutions} -${nanosecondsAtStartOfExecutions})/1000000000")"

    echo -e "\e[1m\n\e[36mDas Auführen hat $(date -u --date @${duration} +%M:%S.%3N) gedauert"
}

tmux(){
    local sessionName="${HOSTNAME}"

    # Check for existing session
    # If there is one:  attach the existing one
    # If there is none: create a new one and then attach it
    if [[ "$(command tmux ls | grep -o ${sessionName})" == "${sessionName}" ]]; then
        command tmux attach-session -t ${sessionName}
    else # if it wasn't there then setup as below
        command tmux new-session -s ${sessionName} -d
        command tmux rename-window "home"
        command tmux split-window -h
        command tmux split-window -v
        command tmux send-keys -t 0.0 'shopt -s checkwinsize; tmux_help' Enter
        command tmux select-pane -t 0
        command tmux -u attach-session -d
    fi
}

tmux_help(){
    echo -e "\e[1;36m"; center "TMUX Hilfe"; echo -e "\n\e[0m" \
    "\nStartkommando:         <\e[1;36mSTRG\e[0m> + <\e[1;36mB\e[0m>\n" \
    "\nTeilen:" \
    "\n    - Horizontal:      <\e[1;36m%\e[0m>" \
    "\n    - Vertikal:        <\e[1;36m\"\e[0m>\n" \
    "\nPanes:" \
    "\n    - Layout wechseln: <\e[1;36mSpace\e[0m>    - Nächstes:            <\e[1;36mO\e[0m>" \
    "\n    - Maximieren:      <\e[1;36mZ\e[0m>        - Panenummer anzeigen: <\e[1;36mQ\e[0m>" \
    "\n    - Schließen:       <\e[1;36mX\e[0m>        - Zu Pane wechseln:    <\e[1;36mQ\e[0m> + <\e[1;36m0-9\e[0m>" \
    "\n                                  - Alternativ:          <\e[1;36mPfeiltasten\e[0m>\n" \
    "\nEinfügen: <\e[1;36mShift\e[0m> + <\e[1;36mMittlere Maustaste\e[0m>"
}

to_lf(){
    [[ -z ${1} ]] && echo -e "\e[31mEs wurde keine Datei, die umgewandelt werden soll, angegeben\e[0m" && return 1

    if [[ "${1}" == "alle" ]]; then
        allFiles=$(find . -type f -not -path "*/\.git/*" | xargs file | grep "CRLF" | cut -d " " -f1 | cut -d ":" -f1)

        [[ -z ${allFiles} ]] && echo -e "\e[33mEs wurde keine Datei, die CRLF Dateienden hat\e[0m" && return

        echo -e "\e[96mSollen die folgenden Dateien zu LF konvertiert werden?\e[0m\n$(echo ${allFiles} | sed 's/ /\n/g' | nl)\n"

        read -e -n1 answer
        [[ ! ${answer} =~ (Y|y|J|j) ]] && return

    else
        allFiles=${@}

    fi

    for file in ${allFiles}; do

        [[ "$(file ${file})" == *"CRLF"* ]] && lineEndings="\e[31mCRLF" || lineEndings="\e[32mLF"

        echo -e "Ändere die Zeilenenden zu LF von \e[96;1m${file}\e[0m\n    War davor: ${lineEndings}\e[0m"

        tr -d '\015' <${file} >"${file}""_new"
        mv "${file}""_new" ${file}
    done
}

complete -F _longopt -W "alle" to_lf

upgrade(){
    echo -e "\e[1;96mAPT wird aufgerufen\n\e[0m"

    sudo apt upgrade ${1} #Falls -y angegeben wurde
    [[ ${?} == 0 ]] || return
    echo -e "\n\e[32mUpdates Abgeschlossen\e[0m"

    if [[ $(hostname) != "openhab" ]]; then
        return
    fi

    openHABIP="localhost"
    itemToBeUpdated="System_Updates"
    newState="0"
    curl -X PUT --header "Content-Type: text/plain" --header "Accept: application/json" -d "${newState}" "http://${openHABIP}:8080/rest/items/${itemToBeUpdated}/state"
    echo -e "\e[1;96mDie Anzahl der Updates wurde aktualisiert\e[0m"
}

which(){
    [[ -z ${1} ]]    && echo -e "\e[31mEs wurde kein Programm angegeben\e[0m"       && return 1
    [[ ${#} -gt 2 ]] && echo -e "\e[31mEs wurden zu viele Argumente angegeben\e[0m" && return 1

    type ${1}

    local isFunction=$(type ${1})
    local fileLocation=$(bash -c "which ${1}")

    if [[ ( ! ${isFunction} == *"ist eine Funktion"* ) && -n ${fileLocation} ]]; then

        if [[ $(file -L ${fileLocation}) =~ (ASCII|script) ]]; then
            echo -e "\nSoll der Sourcecode angezeigt werden? \e[2m(J/N)\e[0m"
            read -e -n1 answer

            [[ ${answer} =~ ^[YyJj]$ ]] && less ${fileLocation}

        else
            #Nicht anzeigen, wenn es sich um einen Alias handelt
            [[ ${isFunction} == *"Alias"* ]] || echo -e "\nEs handelt sich um eine Binärdatei"

        fi
    fi
    return 0
}
#!/bin/bash

file_info(){
    [[ -z ${1} ]] && echo -e "\e[31mEs wurde kein Dateiname angegeben\e[0m" && return 1
    [[ ${1} == "." ]] && files=$(find . -type f -not -path "*/\.git/*") || files="$@"
    local counter=0
    local anzahl=$(echo $files | wc -w)
	for file in $files; do
		((counter++))
		[[ -d $file ]] && echo -e "\e[31m\"$file\" ist ein Ordner\e[0m" && continue
		[[ ! -f $file ]] && echo -e "\e[31mDie Datei \"$file\" exisitiert nicht\e[0m" && continue
    	dateiname=$(basename $file)
        echo -e "\e[1;96mDateiname:\t$dateiname\e[0m"
        kompletter_pfad=$(realpath $file)
        echo -e "Absoluter Pfad:\t$kompletter_pfad"
    	echo -e "Größe:\t\t$(du -h $file | cut -f1)"
    	echo -e "Anzahl Zeilen:\t$(cat $file | wc -l | sed ':a;s/\B[0-9]\{3\}\>/.&/;ta')" #sed baut Tausender-Punkte ein
    	echo -e "Modifiziert:\t$(find $file -printf "%CH:%CM:%.2CS Uhr, %Cd.%Cm.%CY (%CA)")"
    	echo -e "Besitzer:\t$(find $file -printf "%u")"
    	echo -e "Gruppe:\t\t$(find $file -printf "%g")"
    	echo -e "Rechte:\t\t$(find $file -printf "%M (%m)" | cut -c 2-)"
    	[[ "$dateiname" =~ ^\..{1,} ]] && versteckt="Ja" ||  versteckt="Nein"
        echo -e "Versteckt:\t$versteckt"
        if [[ $(file $file) == *"CRLF"* ]]; then
            [[ "${kompletter_pfad##*.}" == "sh" ]] && zeilenenden="\e[31mCRLF\e[0m" || zeilenenden="CRLF"
        else
            zeilenenden="LF"
        fi
    	echo -e "Zeilenenden:\t$zeilenenden"
        [ "$anzahl" -gt "$counter" ] && echo -e "\n\n"
    done
    return 0
}


git_log(){
    if ! check_if_repo_exists; then return 1; fi

    [[ $(git_url -u) == *"abm-local.de"* ]] && repo="abm" || repo=""

    local commitcount=30

    [[ ${1} =~ ^[0-9]{1,}$ ]] && commitcount=${1}

    if [[ $commitcount == 1 ]]; then
        git --no-pager log -n $commitcount --reverse --pretty="    %cd | %h | " --date=format:"%a | %d.%m. | %H:%M:%S" > /tmp/.hashandtime
    else
        git --no-pager log -n $commitcount --reverse --pretty="| %cd | %h | " --date=format:"%a | %d.%m. | %H:%M:%S" | nl > /tmp/.hashandtime
    fi
    git --no-pager log -n $commitcount --reverse --pretty="%ae" | cut -c -2 | tr a-z A-Z > /tmp/.commitauthor
    git --no-pager log -n $commitcount --reverse --pretty="%h§" --shortstat | sed -z 's/§\n\n//g' > /tmp/.statsofcommits
    git --no-pager log -n $commitcount --reverse --pretty=" %s" > /tmp/.messagesofcommits

    IFS=$'\n'

    local linecounter=0
    local max_files_changed=0
    local max_insertions=0
    local max_deletions=0

    # Wenn kein "changed" in der Zeile ist, handelt es sich wahrscheinlich um einen Merge und das
    # "files changed" wird von git nicht ausgegeben, somit muss es erst per git diff geholt werden
    # &
    # Maxmimale Anzahl geänderter Files, Insertions & Deletions herausfinden
    while read -r line; do
        ((linecounter++))
        echo -ne "Log wird geparsed ($linecounter/$commitcount)\r"

        local newline
        if [[ $line == *changed* ]]; then
            newline=$(echo $line | cut -d " " -f2-)
        else
            local hash=$(echo $line | sed 's/§//')
            newline="$(git diff $hash^ $hash --stat | grep "changed,")"
        fi
        sed -i "s/$line/$newline/" /tmp/.statsofcommits

        local files_changed=$(echo $newline | grep -Eo '[0-9]+' | head -1)
        local insertions=0
        [[ $newline == *"insertion"* ]] && insertions=$(echo $newline | grep -Eo '[0-9]+' | sed -n 2p)
        local deletions=0
        [[ $newline == *"deletion"* ]] && deletions=$(echo $newline | grep -Eo '[0-9]+' | tail -1)

        [[ $files_changed -gt $max_files_changed ]] && max_files_changed=$files_changed
        [[ $insertions    -gt $max_insertions    ]] && max_insertions=$insertions
        [[ $deletions     -gt $max_deletions     ]] && max_deletions=$deletions
    done < /tmp/.statsofcommits

    echo -ne "                                               \r" #"Log wird geparsed" überschreiben

    local len_of_max_files_changed=$(echo $max_files_changed | wc -c)
    local len_of_max_insertions=$(echo $max_insertions | wc -c)
    local len_of_max_deletions=$(echo $max_deletions | wc -c)

    ((len_of_max_files_changed--)) #wc -w is +1, aber nur bei der Variablen abziehen, da die anderen noch "+"/"-" haben

    linecounter=0
    cat /tmp/.hashandtime | while read -r line; do #Ausgabe der ganzen Infos
        ((linecounter++))
        local commitauthor=$(sed -n ${linecounter}p /tmp/.commitauthor)
        echo -n $line
        [[ $repo == "abm" ]] && echo -n "$commitauthor | "
        local statsline=$(sed -n ${linecounter}p /tmp/.statsofcommits)
        local files_changed=$(echo $statsline | grep -Eo '[0-9]+' | head -1)
        local insertions=0
        [[ $statsline == *"insertion"* ]] && insertions=$(echo $statsline | grep -Eo '[0-9]+' | sed -n 2p)
        local deletions=0
        [[ $statsline == *"deletion"* ]] && deletions=$(echo $statsline | grep -Eo '[0-9]+' | tail -1)
        printf "%${len_of_max_files_changed}s" "$files_changed"
        printf " (\e[32m%${len_of_max_insertions}s\e[0m" "+$insertions"
        printf " \e[31m%${len_of_max_deletions}s\e[0m)" "-$deletions"
        echo -e " |"$(sed -n ${linecounter}p /tmp/.messagesofcommits)
    done

    rm -f /tmp/{.hashandtime,.statsofcommits,.messagesofcommits,.commitauthor,.mergestats}

    while true; do
        echo -e "\n\e[96;1m"
        center "Soll ein Commit angezeigt werden?"
        echo -e "\e[0m"
        read -e answer
        [[ -z $answer ]] && break
        local commithash
        if [[ $answer =~ ^[0-9]{1,2}$ && $answer -le 30  ]]; then
            commithash=$(git --no-pager log -n 30 --reverse --pretty="%h" | sed -n ${answer}p)
        elif [[ $answer =~ ^[0-9a-z]{5,}$ ]]; then
            commithash=$answer
        else
            echo -e "\e[31mDie Antwort konnte nicht interpretiert werden\e[0m"
            continue
        fi
        git show $commithash
    done
}

git_url(){
    if ! check_if_repo_exists; then return 1; fi

    session_typ="lokal"
    if [ -n "$SSH_CLIENT" ] || [ -n "$SSH_TTY" ]; then
        session_typ=ssh
    else
        case $(ps -o comm= -p $PPID 2>/dev/null) in
            sshd|*/sshd) session_typ=ssh;;
        esac
    fi
    local url=$(git config --get remote.origin.url | sed 's/:/\//'| sed 's/\.git//' | sed 's/git@/https:\/\//g')
    local branch=$(git branch | grep "*" | cut -d" " -f2-)
    local open_url="$url"
    [[ $branch =~ (master|main) ]] || open_url+="/-/tree/"$branch

    [[ -z $url ]] && echo -e "\e[31mDie URL konnte nicht bestimmt werden! \e[0m]" && return 1
    echo -e "Repository URL: \e[96m$url\e[0m"
    [[ $branch =~ (master|main) ]] || echo -e "Branch URL: \e[96m$open_url\e[0m"
    [[ $session_typ != "ssh" && $(command -v "xdg-open" 2>/dev/null) != "" && ${1} != "-u" ]] && xdg-open "$open_url"
}

repeat(){
    [ $# -gt 2 ]  && echo -e "\e[31mEs wurden zu viele Argumente angegeben\e[0m" && return 1
    [[ -z ${2} ]] && sleeptime="1.0" || sleeptime=$(echo ${2} | sed 's/,/./')
    local counter=0
    while (true); do
        ((counter ++))

        heading="   $(date +%T)   |   Durchlauf: $counter   |   Alle $(echo $sleeptime | sed 's/\./,/')s   |   Kommando: ${1}   "
        [ "${#heading}" -ge "$(tput cols)" ] && heading="   $(date +%T)   |   Durchlauf: $counter   |   Alle $(echo $sleeptime | sed 's/\./,/')s   "
        echo -e "\n\e[96;1m"; center "$heading"; echo -e "\e[0m"

        bash -c "${1}"
        read -t $sleeptime
    done
}

sa(){
    [[ -z ${1} ]] && echo -e "\e[31mEs wurde kein Name angegeben\e[0m"             && return 1
    [[ -f ${1} ]] && echo -e "\e[31mDie Datei exisitiert bereits\e[0m"             && return 1
    [ $# -gt 1 ]  && echo -e "\e[31mEs wurden zu viele Argumente angegeben\e[0m"   && return 1

    filename="${1}"
    touch $filename
    chmod +x $filename
    if [[ $filename == *".sh" ]]; then
        echo -e "#!/bin/bash\n\n" >> $filename
    elif [[ $filename == *".py" ]]; then
        echo -e "#!/usr/bin/python3\n# -*- coding: utf-8 -*-\n\n" >> $filename
    fi
    [[ $(command -v code) != "" ]] && code $filename || nano +8 $filename

    echo -e "\e[32mSoll das Script ausgeführt werden?\e[0m"
    read -e -n1 answer
    if [[ $answer =~ ^[YyJj]$ ]]; then
        if [[ -f $filename ]]; then
            echo -e "\e[1;96m"; center "$filename"; echo -e "\n\e[0m"
            ./$filename
        else
            echo -e "\e[31mDas Script existiert nicht mehr!\e[0m"
            return 1
        fi
    else
        echo -e "\e[33mDas Script wird nicht ausgeführt\e[0m"
        return 1
    fi
}

search_string(){
    [[ -z ${1} ]] && echo -e "\e[31mEs wurde kein Suchbegriff angegeben\e[0m"      && return 1
    [ $# -gt 2 ]  && echo -e "\e[31mEs wurden zu viele Argumente angegeben\e[0m"   && return 1
    if [[ $# == 1 ]]; then
        grep -inrs --color=always "${1}" ./* || echo -e "\e[33mEs wurden keine Sucherergbnisse gefunden\e[0m"
    else
        grep -inrs --color=always "${1}" "${2}" || echo -e "\e[33mEs wurden keine Sucherergbnisse gefunden\e[0m"
    fi
}

search_file(){
    [[ -z ${1} ]] && echo -e "\e[31mEs wurde kein Suchbegriff angegeben\e[0m"      && return 1
    #Grep, um eine Fehlermeldung bei keinen Suchergebnissen anzeigen zu können und die Fundorte farbig zu markieren
    if [[ $# == 1 ]]; then
        if [[ -n $(find . -maxdepth 1 -type d -iname "customers") && $(hostname) == "frank" ]]; then #Ausnahme für frank
            echo -e "\e[33mSoll auch im customers-Ordner gesucht werden?\e[0m"
            read -e -n1 answer
            if [[ $answer =~ ^[YyJj]$ ]]; then
                find . -iname "*${1}*" -not -path "*/\.git/*" | grep -i "${1}" --color=always || echo -e "\e[33mEs wurden keine Sucherergbnisse gefunden\e[0m"
            else
                find . -iname "*${1}*" -not -path "./customers/*" -not -path "*/\.git/*" | grep -i "${1}" --color=always || echo -e "\e[33mEs wurden keine Sucherergbnisse gefunden\e[0m"
            fi
        else
            find . -iname "*${1}*" -not -path "*/\.git/*" | grep -i "${1}" --color=always || echo -e "\e[33mEs wurden keine Sucherergbnisse gefunden\e[0m"
        fi
    else
        local suchbegriff=${1}
        shift
        find "$@" -iname "*$suchbegriff*" -not -path "*/\.git/*" | grep -i "$suchbegriff" --color=always || echo -e "\e[33mEs wurden keine Sucherergbnisse gefunden\e[0m"
    fi
}

stopwatch(){
    [ $# -lt 1 ] && echo -e "\e[31mEs wurde kein Befehl angegeben\e[0m" && return 1
    local argumente="$(echo $@ | sed 's/"/\\"/g')"
    local start=$(date +%s,%N)
    bash -c "$argumente"
    local end=$(date +%s,%N)
    local _s1=$(echo $start | cut -d',' -f1); local _s2=$(echo $start | cut -d',' -f2)
    local _e1=$(echo $end | cut -d',' -f1);   local _e2=$(echo $end | cut -d',' -f2)
    local dauer="0""$(bc <<< "scale=3; $_e1 - $_s1 + ($_e2 -$_s2)/1000000000")"
    echo -e "\e[1m\n\e[36mDas Auführen hat $(date -u --date @$dauer +%M:%S.%3N) gedauert"
}

tmux_help(){
    echo -e "\e[1;36m"; center "TMUX Hilfe"; echo -e "\n\e[0m" \
    "\nStartkommando:         <\e[1;36mSTRG\e[0m> + <\e[1;36mB\e[0m>\n" \
    "\nTeilen:" \
    "\n    - Horizontal:      <\e[1;36m%\e[0m>" \
    "\n    - Vertikal:        <\e[1;36m\"\e[0m>\n" \
    "\nPanes:" \
    "\n    - Layout wechseln: <\e[1;36mSpace\e[0m>    - Nächstes:            <\e[1;36mO\e[0m>" \
    "\n    - Maximieren:      <\e[1;36mZ\e[0m>        - Panenummer anzeigen: <\e[1;36mQ\e[0m>" \
    "\n    - Schließen:       <\e[1;36mX\e[0m>        - Zu Pane wechseln:    <\e[1;36mQ\e[0m> + <\e[1;36m0-9\e[0m>" \
    "\n                                  - Alternativ:          <\e[1;36mPfeiltasten\e[0m>\n" \
    "\nEinfügen: <\e[1;36mShift\e[0m> + <\e[1;36mMittlere Maustaste\e[0m>"
}

to_lf(){
    [[ -z ${1} ]] && echo -e "\e[31mEs wurde keine Datei, die umgewandelt werden soll, angegeben\e[0m" && return 1
    if [[ "$1" == "alle" ]]; then
        files=$(find . -type f -not -path "*/\.git/*" | xargs file | grep "CRLF" | cut -d " " -f1 | cut -d ":" -f1)
        [[ -z $files ]] && echo -e "\e[33mEs wurde keine Datei, die CRLF Dateienden hat\e[0m" && return
        echo -e "\e[96mSollen die folgenden Dateien zu LF konvertiert werden?\e[0m\n$(echo $files | sed 's/ /\n/g' | nl)\n"
        read -e -n1 answer
        [[ ! $answer =~ (Y|y|J|j) ]] && return
    else
        files=$@
    fi
    for file in $files; do
        [[ "$(file $file)" == *"CRLF"* ]] && zeilenenden="\e[31mCRLF" || zeilenenden="\e[32mLF"
        echo -e "Ändere die Zeilenenden zu LF von \e[96;1m$file\e[0m\n    War davor: $zeilenenden\e[0m"
        tr -d '\015' <$file >"$file""_new"
        mv "$file""_new" $file
    done
}

complete -F _longopt -W "alle" to_lf

upgrade(){
    echo -e "\e[1;96mAPT wird aufgerufen\n\e[0m"
    sudo apt upgrade $1 #Falls -y angegeben wurde
    [[ $? == 0 ]] || return
    echo -e "\n\e[32mUpdates Abgeschlossen\e[0m"
    if [[ $(hostname) == "openhab" ]]; then
        OHIP="localhost"
        item="System_Updates"
        state="0"
        curl -X PUT --header "Content-Type: text/plain" --header "Accept: application/json" -d "$state" "http://$OHIP:8080/rest/items/$item/state"
        echo -e "\e[1;96mDie Anzahl der Updates wurde aktualisiert\e[0m"
    fi
}

which(){
    [[ -z ${1} ]] && echo -e "\e[31mEs wurde kein Programm angegeben\e[0m"       && return 1
    [ $# -gt 2 ]  && echo -e "\e[31mEs wurden zu viele Argumente angegeben\e[0m" && return 1
    type $1
    local isFunction=$(type $1)
    local filelocation=$(bash -c "which $1")
    if [[ ( ! $isFunction == *"ist eine Funktion"* ) && -n $filelocation ]]; then
        if [[ $(file -L  $filelocation) =~ (ASCII|script) ]]; then
            echo -e "\nSoll der Sourcecode angezeigt werden? \e[2m(J/N)\e[0m"
            read -e -n1 answer
            if [[ $answer =~ ^[YyJj]$ ]]; then
                less $filelocation
            fi
        else
            if [[ $isFunction != *"Alias"* ]]; then #Nicht anzeigen, wenn es sich um einen Alias handelt
                echo -e "\nEs handelt sich um eine Binärdatei"
            fi
        fi
    fi
    return 0
}
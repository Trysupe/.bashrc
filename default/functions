#!/bin/bash

# shellcheck disable=2015,2155

cd() {
    # Macht ein normales cd, wenn ein Verzeichnis angegeben wurde
    # Schneidet den Dateinamen ab, wenn ein Verzeichnis mit folgendem Dateinamen angegeben wurde
    # Beispiel:
    # ┌─[11:40:57]-[:)]-[fschneider@frank]-[/tmp/]
    # └──> cd Resources/305075061F05.xml
    #
    # ┌─[11:41:03]-[:)]-[fschneider@frank]-[/tmp/Resources/]
    # └──>

    [[ ${1} == "--" ]] && shift

    [[ ${#} -gt 1 ]] && echo -e "\e[31mEs wurden zu viele Argumente angegeben\e[0m" && return 1

    local targetDirectory
    [[ -z ${1} ]] && targetDirectory=${HOME} || targetDirectory=${1} # Bei keiner Angabe ins Homeverzeichnis wechseln

    local fileToBeChecked
    [[ ${1} == "/"* ]] && fileToBeChecked="${1}" || fileToBeChecked="$(pwd)/${1}" # Check, ob ein absoluter Pfad angegeben wurde

    [[ -f ${fileToBeChecked} ]] && targetDirectory=$(dirname "${1}")

    command cd "${targetDirectory}" || return 1
}

ds() { # Docker Shell
    [[ -z ${1} ]] && echo -e "\e[31mEs wurde kein Containername angegeben\e[0m" && return 1
    [[ ${#} -gt 1 ]] && echo -e "\e[31mEs wurden zu viele Argumente angegeben\e[0m" && return 1

    docker exec -it "${1}" bash
}

dl() { # Docker Logs
    [[ -z ${1} ]] && echo -e "\e[31mEs wurde kein Containername angegeben\e[0m" && return 1
    [[ ${#} -gt 1 ]] && echo -e "\e[31mEs wurden zu viele Argumente angegeben\e[0m" && return 1

    docker logs -f -n 1000 "${1}"
}

_docker_containers_completion() {
    for item in $(docker ps --format "{{.Names}}" | grep -P "^${COMP_WORDS[${COMP_CWORD}]}"); do
        COMPREPLY=("${COMPREPLY[@]}" "${item}")
    done
}

complete -F _docker_containers_completion ds dl

file_info() {
    [[ -z ${1} ]] && echo -e "\e[31mEs wurde kein Dateiname angegeben\e[0m" && return 1

    [[ ${1} == "." ]] && allFiles=$(find . -type f -not -path "*/\.git/*") || allFiles="${*}"

    local counter=0
    local amountOfFiles=$(echo "${allFiles}" | wc -w)

    for file in ${allFiles}; do
        ((counter++))

        [[ -d ${file} ]] && echo -e "\e[31m\"${file}\" ist ein Ordner\e[0m" && continue
        [[ ! -f ${file} ]] && echo -e "\e[31mDie Datei \"${file}\" exisitiert nicht\e[0m" && continue

        filename=$(basename "${file}")
        echo -e "\e[1;96mDateiname:\t${filename}\e[0m"
        absolutePath=$(realpath "${file}")
        echo -e "Absoluter Pfad:\t${absolutePath}"
        echo -e "Größe:\t\t$(du -h "${file}" | cut -f1)"
        echo -e "Anzahl Zeilen:\t$(wc -l <"${file}" | sed ':a;s/\B[0-9]\{3\}\>/.&/;ta')" # sed baut Tausender-Punkte ein
        echo -e "Modifiziert:\t$(find "${file}" -printf "%CH:%CM:%.2CS Uhr, %Cd.%Cm.%CY (%CA)")"
        echo -e "Besitzer:\t$(find "${file}" -printf "%u")"
        echo -e "Gruppe:\t\t$(find "${file}" -printf "%g")"
        echo -e "Rechte:\t\t$(find "${file}" -printf "%M (%m)" | cut -c 2-)"

        [[ "${filename}" =~ ^\..{1,} ]] && fileHidden="Ja" || fileHidden="Nein"
        echo -e "Versteckt:\t${fileHidden}"

        if [[ $(file "${file}") == *"CRLF"* ]]; then
            [[ "${absolutePath##*.}" == "sh" ]] && lineEndings="\e[31mCRLF\e[0m" || lineEndings="CRLF"
        else
            lineEndings="LF"
        fi
        echo -e "Zeilenenden:\t${lineEndings}"

        [[ "${amountOfFiles}" -gt "${counter}" ]] && echo -e "\n\n"
    done

    return 0
}

git_checkout_history() {
    local urlOfRepository=$(git_base_url)
    [[ -z ${urlOfRepository} ]] && return 1 # Stoppen, falls es sich nicht um ein Git-Repo handelt

    git reflog --format=' - %<(14)%cr | %<(70)%gs | %s' |
        grep "checkout:" |
        head -n 15 |
        tac |
        sed 's/checkout: moving from //g;s/to/-->/g'
}

git_history() {
    local urlOfRepository=$(git_base_url)
    [[ -z ${urlOfRepository} ]] && return 1 # Stoppen, falls es sich nicht um ein Git-Repo handelt

    local space=" "
    local onlyCommitUrl=false
    if [[ ${1} == "-u" ]]; then
        local onlyCommitUrl=true
        space=""
        shift
    fi

    local urlOfHistoryOfRepository="${urlOfRepository}/commits"

    if [[ ! ${1} =~ [0-9]+ ]]; then
        echo -e "History URL: \e[96m${urlOfHistoryOfRepository}\e[0m"

        local typeOfSession=$(is_session_ssh)
        [[ ${typeOfSession} != "ssh" && $(command -v "xdg-open" 2>/dev/null) != "" ]] && xdg-open "${urlOfHistoryOfRepository}"
        return 0

    else
        [[ ${onlyCommitUrl} == false ]] && echo -e "History URL: ${urlOfHistoryOfRepository}"
    fi

    local commitHash

    if [[ ${1} =~ ^[0-9]{1,5}$ ]]; then
        local amountOfCommitsInRepository=$(git rev-list --count HEAD)
        local nthCommitToBeShown=$((${1} - 1))
        [[ ${nthCommitToBeShown} -gt ${amountOfCommitsInRepository} ]] && echo -e "\e[31mEs gibt nur ${amountOfCommitsInRepository} Commits in diesem Repo! \e[0m" && return 1

        commitHash=$(git log -1 HEAD~${nthCommitToBeShown} --pretty="%H")
    else
        commitHash=$(git rev-parse "${1}" 2>/dev/null) # Langen Commithash zum kurzen Input bekommen
        # shellcheck disable=2181
        if [[ ${?} != 0 ]]; then
            echo -e "\e[31mEs konnte kein Commit zu dem Hash gefunden werden\e[0m"
            return 1
        fi
    fi

    local urlOfCommit="${urlOfRepository}/commit/${commitHash}"

    echo -e "\e[32mCommit URL:\e[0m ${space}\e[96m${urlOfCommit}\e[0m"
}

git_issues() {
    local urlOfRepository=$(git_base_url)
    [[ -z ${urlOfRepository} ]] && return 1 # Stoppen, falls es sich nicht um ein Git-Repo handelt

    local typeOfSession=$(is_session_ssh)

    local urlOfIssues="${urlOfRepository}""/issues/"

    echo -e "URL: \e[96m${urlOfIssues}\e[0m"

    [[ ${typeOfSession} != "ssh" && $(command -v "xdg-open" 2>/dev/null) != "" ]] && xdg-open "${urlOfIssues}"

    return 0
}

git_last_pull() {
    if ! check_if_git_repo_exists; then return 1; fi

    local fetchHeadFile="$(git rev-parse --show-toplevel)/.git/FETCH_HEAD"
    # Wenn das Verzeichnis in Windows liegt, aber die Session im WSL ist muss der Pfad angepasst werden
    # C:/Users/fschneider/repos/bashrc --> /mnt/c/Users/fschneider/repos/bashrc
    # shellcheck disable=2154
    if [[ ${is_wsl} == true ]]; then
        fetchHeadFile=${fetchHeadFile/C:/\/mnt\/c}
    fi

    [[ ! -f ${fetchHeadFile} ]] && return # Check if file exsits

    local pullDate=$(date -r "${fetchHeadFile}" +%D)
    local pullTime=$(date -r "${fetchHeadFile}" +'%H:%M:%S Uhr')

    if [[ ${pullDate} == $(date +%D) ]]; then
        echo -n "Der letzte Pull war heute"
    elif [[ ${pullDate} == $(date +%D --date="1 day ago") ]]; then
        echo -n "Der letzte Pull war gestern"
    else
        daysSince=$((($(date +%s) - $(date --date="${pullDate}" +%s)) / (60 * 60 * 24)))
        echo -n "Der letzte Pull war vor ${daysSince} Tagen am $(LANG=de_DE.UTF-8 date -r "${fetchHeadFile}" +'%A, den %d.%m.')"
    fi
    echo " um ${pullTime}"

    return 0
}

git_log() {
    if ! check_if_git_repo_exists; then return 1; fi

    [[ $(git_url -u) == *"abm-local.de"* ]] && repo="abm" || repo=""

    local amountOfCommits="30"
    local commitsOfBranchToShow="$(git rev-parse --abbrev-ref HEAD)" # Argument supplied by default/diff/function that supplies what commits to show (..origin/${branch}"

    [[ -n ${1} ]] && amountOfCommits="${1}"
    [[ -n ${2} ]] && commitsOfBranchToShow="${2}"

    local amountOfCommitsInRepository=$(git rev-list --count HEAD)
    if [[ ${amountOfCommitsInRepository} -lt ${amountOfCommits} ]]; then
        echo -e "\e[33mEs gibt nur ${amountOfCommitsInRepository} Commits in diesem Repo! \e[0m"
        amountOfCommits=${amountOfCommitsInRepository}
    fi

    IFS=$'\n'
    if [[ ${amountOfCommits} == 1 ]]; then
        read -r -d $'\0' -a hashandtime <<<"$(git --no-pager log -n"${amountOfCommits}" --reverse "${commitsOfBranchToShow}" --pretty="    %ad | %h | " --date=format:"%a | %d.%m. | %H:%M:%S")"
    else
        read -r -d $'\0' -a hashandtime <<<"$(git --no-pager log -n"${amountOfCommits}" --reverse "${commitsOfBranchToShow}" --pretty="| %ad | %h | " --date=format:"%a | %d.%m. | %H:%M:%S" | nl)"
    fi
    read -r -d $'\0' -a commitAuthor <<<"$(git --no-pager log -n"${amountOfCommits}" --reverse "${commitsOfBranchToShow}" --pretty="%ae" | cut -c -2)"
    read -r -d $'\0' -a statsOfCommit <<<"$(git --no-pager log -n"${amountOfCommits}" --reverse "${commitsOfBranchToShow}" --pretty="%h§" --shortstat | sed -z 's/§\n\n//g')" # TODO: sed entfernen da langsam
    read -r -d $'\0' -a messageOfCommit <<<"$(git --no-pager log -n"${amountOfCommits}" --reverse "${commitsOfBranchToShow}" --pretty=" %s")"

    local lineCounter=0     # Holds the progress while iterating though the array
    local maxFilesChanged=0 # Saves the maximum ammount of files changed of all commits
    local maxInserions=0    # Saves the maximum ammount of intertions of all commits
    local maxDeletions=0    # Saves the maximum ammount of deletions of all commits

    # Maxmimale Anzahl geänderter Files, Insertions & Deletions herausfinden
    for line in "${statsOfCommit[@]}"; do
        local newline
        # If there is no "changed" in the line the commit is probably a merge commit from a MR
        # If so git doesn't show the usual "g files changed, h insertions(+), i deletions(-)" so it has to be fetched from git diff
        if [[ ${line} == *changed* ]]; then
            newline=$(echo "${line}" | cut -d " " -f2-)
        else
            local hash="${line//§/}"
            newline="$(git diff "${hash}"^ "${hash}" --stat | grep "changed,")"
        fi

        local filesChanged=$(echo "${newline}" | grep -Eo '[0-9]+' | head -1)
        local insertions=0
        [[ ${newline} == *"insertion"* ]] && insertions=$(echo "${newline}" | grep -Eo '[0-9]+' | sed -n 2p)
        local deletions=0
        [[ ${newline} == *"deletion"* ]] && deletions=$(echo "${newline}" | grep -Eo '[0-9]+' | tail -1)

        statsOfCommit[${lineCounter}]="${filesChanged} ${insertions} ${deletions}"

        [[ ${filesChanged} -gt ${maxFilesChanged} ]] && maxFilesChanged=${filesChanged}
        [[ ${insertions} -gt ${maxInserions} ]] && maxInserions=${insertions}
        [[ ${deletions} -gt ${maxDeletions} ]] && maxDeletions=${deletions}
        ((lineCounter++))
        echo -ne "Log wird geparsed (${lineCounter}/${amountOfCommits})\r"
    done

    echo -ne "                                               \r" #"Log wird geparsed" überschreiben

    local lenOfMaxFilesChanged=${#maxFilesChanged}
    local lenOfMaxInserions=${#maxInserions}
    local lenOfMaxDeletions=${#maxDeletions}

    ((lenOfMaxInserions++))
    ((lenOfMaxDeletions++))

    lineCounter=0
    for line in "${hashandtime[@]}"; do # Ausgabe der ganzen Infos
        echo -n "${line}"
        [[ ${repo} == "abm" ]] && echo -n "${commitAuthor[${lineCounter}]^^} | "
        local statsline=${statsOfCommit[${lineCounter}]}

        local filesChanged=$(echo "${statsline}" | cut -d " " -f1)
        local insertions=$(echo "${statsline}" | cut -d " " -f2)
        local deletions=$(echo "${statsline}" | cut -d " " -f3)

        printf "%${lenOfMaxFilesChanged}s" "${filesChanged}"
        printf " (\e[32m%${lenOfMaxInserions}s\e[0m" "+${insertions}"
        printf " \e[31m%${lenOfMaxDeletions}s\e[0m)" "-${deletions}"
        echo -e " |${messageOfCommit[${lineCounter}]}"
        ((lineCounter++))
    done

    [[ -n ${commitsOfBranchToShow} ]] && return

    while true; do
        echo -e "\n\e[96;1m"
        center "Soll ein Commit angezeigt werden?"
        echo -e "\e[0m"
        read -r -e answer
        [[ -z ${answer} ]] && break
        local commitHash
        if [[ ${answer} =~ ^[0-9]{1,2}$ && ${answer} -le ${amountOfCommits} ]]; then
            commitHash=$(git --no-pager log -n 30 --reverse --pretty="%h" | sed -n "${answer}"p)
        elif [[ ${answer} =~ ^[0-9a-z]{5,}$ ]]; then
            commitHash=${answer}
        else
            echo -e "\e[31mDie Antwort konnte nicht interpretiert werden\e[0m"
            continue
        fi
        git show "${commitHash}"
    done
}

git_sign_off() { # Zum Anzeigen der Signierungsnachricht
    echo "Signed-off-by: $(git config user.name) <$(git config user.email)>"
}

git_url() {
    local urlOfRepository=$(git_base_url)
    [[ -z ${urlOfRepository} ]] && return 1 # Stoppen, falls es sich nicht um ein Git-Repo handelt

    local typeOfSession=$(is_session_ssh)

    echo -e "Repository URL: \e[96m${urlOfRepository}\e[0m"
    [[ ${typeOfSession} != "ssh" && $(command -v "xdg-open" 2>/dev/null) != "" && ${1} != "-u" ]] && xdg-open "${urlOfRepository}"
}

psgrep() {
    [[ -z ${1} ]] && echo -e "\e[31mEs wurde kein Suchbegriff angegeben\e[0m" && return 1

    ps aux | head -n 1
    # shellcheck disable=2009
    ps aux -H | grep -i "${*}"
}

repeat() {
    [ ${#} -gt 2 ] && echo -e "\e[31mEs wurden zu viele Argumente angegeben\e[0m" && return 1

    [[ -z ${2} ]] && sleeptime="1.0" || sleeptime="${2//,/\.}"

    local counter=0
    while (true); do
        ((counter++))

        header="   $(date +%T)   |   Durchlauf: ${counter}   |   Alle ${sleeptime//,/\.}s   |   Kommando: ${1}   "
        [ "${#header}" -ge "$(tput cols)" ] && header="   $(date +%T)   |   Durchlauf: ${counter}   |   Alle ${sleeptime//,/\.}s   "
        echo -e "\n\e[96;1m"
        center "${header}"
        echo -e "\e[0m"

        eval "${1}"
        read -r -t "${sleeptime}"
    done
}

complete -F _command repeat # Autovervollständigung mit allen verfügbaren Kommandos

sa() {
    [[ -z ${1} ]] && echo -e "\e[31mEs wurde kein Name angegeben\e[0m" && return 1
    [[ -f ${1} ]] && echo -e "\e[31mDie Datei exisitiert bereits\e[0m" && return 1
    [[ ${#} -gt 1 ]] && echo -e "\e[31mEs wurden zu viele Argumente angegeben\e[0m" && return 1

    filename="${1}"
    touch "${filename}"
    chmod +x "${filename}"

    if [[ ${filename} == *".sh" ]]; then
        echo -e "#!/bin/bash\n\n" >>"${filename}"

    elif [[ ${filename} == *".py" ]]; then
        echo -e "#!/usr/bin/python3\n# -*- coding: utf-8 -*-\n\n" >>"${filename}"

    fi

    [[ -n $(command -v code) ]] && code "${filename}" || nano +8 "${filename}"

    echo -e "\e[32mSoll das Script ausgeführt werden?\e[0m"
    read -r -e -n1 answer
    if [[ ${answer} =~ ^[YyJj]$ ]]; then
        if [[ -f ${filename} ]]; then
            echo -e "\e[1;96m"
            center "${filename}"
            echo -e "\n\e[0m"
            eval "${filename}"

        else
            echo -e "\e[31mDas Script existiert nicht mehr!\e[0m"
            return 1

        fi

    else
        echo -e "\e[33mDas Script wird nicht ausgeführt\e[0m"
        return 1
    fi
}

search_string() {
    [[ -z ${1} ]] && echo -e "\e[31mEs wurde kein Suchbegriff angegeben\e[0m" && return 1
    [[ ${#} -gt 2 ]] && echo -e "\e[31mEs wurden zu viele Argumente angegeben\e[0m" && return 1

    if [[ ${#} == 1 ]]; then
        grep -inrs --color=always "${1}" ./* || echo -e "\e[33mEs wurden keine Sucherergbnisse gefunden\e[0m"
    else
        grep -inrs --color=always "${1}" "${2}" || echo -e "\e[33mEs wurden keine Sucherergbnisse gefunden\e[0m"
    fi
}

search_file() {
    [[ -z ${1} ]] && echo -e "\e[31mEs wurde kein Suchbegriff angegeben\e[0m" && return 1

    # grep, um eine Fehlermeldung bei keinen Suchergebnissen anzeigen zu können und die Fundorte farbig zu markieren
    if [[ ${#} == 1 ]]; then
        find . -iname "*${1}*" -not -path "*/\.git/*" | grep -i "${1}" --color=always ||
            echo -e "\e[33mEs wurden keine Sucherergbnisse gefunden\e[0m"
    else
        local fileToSearchFor=${1}
        shift
        find "${@}" -iname "*${fileToSearchFor}*" -not -path "*/\.git/*" | grep -i "${fileToSearchFor}" --color=always ||
            echo -e "\e[33mEs wurden keine Sucherergbnisse gefunden\e[0m"
    fi
}

ssh_permissions() {
    local ssh_path=${HOME}/.ssh
    [[ -d ${ssh_path} ]] || return
    chmod 700 "${ssh_path}"
    [[ -f ${ssh_path}/id_ed25519.pub ]] && chmod 644 ~/.ssh/id_ed25519.pub
    [[ -f ${ssh_path}/id_ed25519 ]] && chmod 600 ~/.ssh/id_ed25519
    [[ -f ${ssh_path}/authorized_keys ]] && chmod 600 ~/.ssh/authorized_keys
    [[ -f ${ssh_path}/config ]] && chmod 600 ~/.ssh/config

    [[ -d /var/lib/openhab2 ]] || return
    sudo -u openhab chmod 700 /var/lib/openhab2/.ssh
    sudo -u openhab chmod 644 /var/lib/openhab2/.ssh/id_ed25519.pub
    sudo -u openhab chmod 600 /var/lib/openhab2/.ssh/id_ed25519 #/var/lib/openhab2/.ssh/config
}

stopwatch() {
    [ ${#} -lt 1 ] && echo -e "\e[31mEs wurde kein Befehl angegeben\e[0m" && return 1

    local commandToRun="${*//\"/\\\"}" # Ersetze '"' durch '\"'

    local startOfExecution=$(date +%s,%N)

    eval "${commandToRun}"

    local endOfExecution=$(date +%s,%N)

    local secondsSinceEpochTillStartOfExecutions=$(echo "${startOfExecution}" | cut -d',' -f1)
    local nanosecondsAtStartOfExecutions=$(echo "${startOfExecution}" | cut -d',' -f2)
    local secondsSinceEpochTillEndOfExecutions=$(echo "${endOfExecution}" | cut -d',' -f1)
    local nanosecondsAtEndOfExecutions=$(echo "${endOfExecution}" | cut -d',' -f2)

    local duration="0""$(bc <<<"scale=3; ${secondsSinceEpochTillEndOfExecutions} - ${secondsSinceEpochTillStartOfExecutions} + (${nanosecondsAtEndOfExecutions} -${nanosecondsAtStartOfExecutions})/1000000000")"

    echo -e "\e[1m\n\e[36mDas Auführen hat $(date -u --date @"${duration}" +%M:%S.%3N) gedauert"
}

tmux() {
    local sessionName="${HOSTNAME}"

    # Check for existing session
    # If there is one:  attach the existing one
    # If there is none: create a new one and then attach it
    if [[ "$(command tmux ls | grep -o "${sessionName}")" == "${sessionName}" ]]; then
        command tmux attach-session -t "${sessionName}"
    else # if it wasn't there then setup as below
        command tmux new-session -s "${sessionName}" -d
        command tmux rename-window "home"
        command tmux split-window -h
        command tmux split-window -v
        command tmux send-keys -t 0.0 'shopt -s checkwinsize; tmux_help' Enter
        command tmux select-pane -t 0
        command tmux -u attach-session -d
    fi
}

tmux_help() {
    echo -e "\e[1;36m"
    center "TMUX Hilfe"
    echo -e "\n\e[0m" \
        "\nStartkommando:         <\e[1;36mSTRG\e[0m> + <\e[1;36mB\e[0m>\n" \
        "\nTeilen:" \
        "\n    - Horizontal:      <\e[1;36m%\e[0m>" \
        "\n    - Vertikal:        <\e[1;36m\"\e[0m>\n" \
        "\nPanes:" \
        "\n    - Layout wechseln: <\e[1;36mSpace\e[0m>    - Nächstes:            <\e[1;36mO\e[0m>" \
        "\n    - Maximieren:      <\e[1;36mZ\e[0m>        - Panenummer anzeigen: <\e[1;36mQ\e[0m>" \
        "\n    - Schließen:       <\e[1;36mX\e[0m>        - Zu Pane wechseln:    <\e[1;36mQ\e[0m> + <\e[1;36m0-9\e[0m>" \
        "\n                                  - Alternativ:          <\e[1;36mPfeiltasten\e[0m>\n" \
        "\nEinfügen: <\e[1;36mShift\e[0m> + <\e[1;36mMittlere Maustaste\e[0m>"
}

to_lf() {
    [[ -z ${1} ]] && echo -e "\e[31mEs wurde keine Datei, die umgewandelt werden soll, angegeben\e[0m" && return 1

    if [[ "${1}" =~ (alle|^\.$) ]]; then
        allFiles=$(find . -type f -not -path "*/\.git/*" -print0 | xargs --null file | grep "CRLF" | cut -d ":" -f1)

        [[ -z ${allFiles} ]] && echo -e "\e[33mEs wurde keine Datei, die CRLF Dateienden hat\e[0m" && return

        echo -e "\e[96mSollen die folgenden Dateien zu LF konvertiert werden?\e[0m\n$(echo "${allFiles}" | sed 's/ /\n/g' | nl)\n"

        read -r -e -n1 answer
        [[ ! ${answer} =~ (Y|y|J|j) ]] && return

    else
        allFiles=${*}

    fi

    for file in ${allFiles}; do

        if [[ ! -f ${file} ]]; then
            echo -e "\e[33mDie Datei \"${file}\" existiert nicht\e[0m"
            continue
        fi

        [[ "$(file "${file}")" == *"CRLF"* ]] && lineEndings="\e[31mCRLF" || lineEndings="\e[32mLF"

        echo -e "Ändere die Zeilenenden zu LF von \e[96;1m${file}\e[0m\n    War davor: ${lineEndings}\e[0m"

        tmp_file=$(mktemp)
        tr -d '\015' <"${file}" >"${tmp_file}"
        mv "${tmp_file}" "${file}"
        rm -f "${tmp_file}"
    done
}

complete -F _longopt -W "alle" to_lf # Autovervollständigung mit allen verfügbaren Dateien

upgrade() {
    echo -e "\e[1;96mAPT wird aufgerufen\n\e[0m"

    if ! sudo apt upgrade "${1}"; then # Falls -y angegeben wurde
        return
    fi
    echo -e "\n\e[32mUpdates Abgeschlossen\e[0m"

    if [[ $(hostname) == "openhab" ]]; then
        openHABIP="localhost"
        itemToBeUpdated="System_Updates"
        newState="0"
        curl -X PUT --header "Content-Type: text/plain" --header "Accept: application/json" -d "${newState}" "http://${openHABIP}:8080/rest/items/${itemToBeUpdated}/state"
        echo -e "\e[1;96mDie Anzahl der Updates wurde aktualisiert\e[0m"
    fi

    if [[ -f /var/run/reboot-required.pkgs ]]; then
        echo -e "\e[33m\nReboot wird benötigt wegen folgenden Paketen:\e[0m"
        sort -u /var/run/reboot-required.pkgs | nl
    fi
}

whats() {
    [[ -z ${1} ]] && echo -e "\e[31mEs wurde kein Programm angegeben\e[0m" && return 1
    [[ ${#} -gt 2 ]] && echo -e "\e[31mEs wurden zu viele Argumente angegeben\e[0m" && return 1

    type "${1}" || return 1

    local isFunction=$(type "${1}")
    local fileLocation=$(command which "${1}")

    if [[ (! ${isFunction} == *"ist eine Funktion"*) && -n ${fileLocation} ]]; then

        if [[ $(file -L "${fileLocation}") =~ (ASCII|script) ]]; then
            echo -e "\nSoll der Sourcecode angezeigt werden? \e[2m(J/N)\e[0m"
            read -r -e -n1 answer

            [[ ${answer} =~ ^[YyJj]$ ]] && less "${fileLocation}"

        else
            # Nicht anzeigen, wenn es sich um einen Alias handelt
            [[ ${isFunction} == *"Alias"* ]] || echo -e "\nEs handelt sich um eine Binärdatei"

        fi
    fi
    return 0
}

complete -F _command whats # Autovervollständigung mit allen verfügbaren Kommandos
